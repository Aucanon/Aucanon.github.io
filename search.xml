<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/20/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/20/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="绑定用户名-邮箱"><a href="#绑定用户名-邮箱" class="headerlink" title="绑定用户名/邮箱"></a>绑定用户名/邮箱</h2><p>下载安装Git后通过Git Bash Here打开Git的命令行窗口配置用户信息。</p><pre><code class="bash">git config --global user.name "your username"git config --global user.email "your email"</code></pre><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>在现有目录中初始化仓库</p><pre><code class="bash">git init</code></pre><h2 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h2><p><code>add .</code> 是将所有文件添加到暂存区，当然也可以单独添加某一文件，将<code>.</code> 直接换为该文件名即可。</p><pre><code class="bash">git add .</code></pre><h2 id="将暂存区内容添加到仓库"><a href="#将暂存区内容添加到仓库" class="headerlink" title="将暂存区内容添加到仓库"></a>将暂存区内容添加到仓库</h2><p>也可以通过添加<code>-a</code> 参数，不需要执行<code>git add</code> 命令直接提交</p><pre><code class="bash">git commit -m "对于此次提交的描述"</code></pre><h2 id="建立远程仓库"><a href="#建立远程仓库" class="headerlink" title="建立远程仓库"></a>建立远程仓库</h2><p>在github或者码云创建新仓库后会有一个仓库的连接方式，可以通过HTTPS协议的连接方式，将自己的url替换到下面</p><pre><code class="bash">git remote add origin url</code></pre><h2 id="推送到代码托管平台"><a href="#推送到代码托管平台" class="headerlink" title="推送到代码托管平台"></a>推送到代码托管平台</h2><p>第一次推送需要加上<code>-u</code> 的参数，以后推送只需要<code>git push</code>命令格式为：<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></p><pre><code class="bash">git push -u origin main</code></pre><p>到此如果没什么问题的话在代码托管平台Github或者Gittee等就应该能看到自己仓库内有了本地的代码了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>盒子模型</title>
      <link href="/2021/11/28/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8F%8AMargin,Border,Padding%EF%BC%89/"/>
      <url>/2021/11/28/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8F%8AMargin,Border,Padding%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>​    盒子模型(Box Modle)，所有的HTML元素都可以看做是一个盒子。CSS盒模型本质上就是一个盒子，然后用这个盒子来封装HTML标签。</p><h4 id="盒子的属性"><a href="#盒子的属性" class="headerlink" title="盒子的属性"></a>盒子的属性</h4><p>盒子总共有五个属性：</p><ul><li><p><code>width,height</code>(元素的高度、宽度)</p></li><li><p><code>Margin</code>(外边距)</p></li><li><p><code>Border</code>(边框)</p></li><li><p><code>Padding</code>(填充)</p></li></ul><p>盒子宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</p><p>盒子高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</p><h4 id="盒子中的区域"><a href="#盒子中的区域" class="headerlink" title="盒子中的区域"></a>盒子中的区域</h4><p><img src="https://i.loli.net/2021/11/28/mN4OogUyX7bqkrx.png" alt="IMG_20211128_144416.png"></p><h2 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h2><h4 id="Margin-1"><a href="#Margin-1" class="headerlink" title="Margin"></a>Margin</h4><p>Margin属性定义了元素周围的空间。可以单独改变元素的上、下、左、右边距，也可以一起改变。<code>Margin</code>没有背景颜色。</p><ul><li><p><code>Margin-top</code></p></li><li><p><code>Margin-right</code></p></li><li><p><code>Margin-bottom</code></p></li><li><p><code>Margin-left</code></p></li></ul><p>值：</p><ul><li><p><code>auto</code> - 设置浏览器边距，取决于浏览器</p></li><li><p><code>length</code> - 以px,pt,cm等单位制定</p></li><li><p><code>%</code> - 定义一个百分比的外边距</p></li></ul><h4 id="Margin的简写属性"><a href="#Margin的简写属性" class="headerlink" title="Margin的简写属性"></a>Margin的简写属性</h4><pre><code class="css">margin：50px 50px 75px 80px;</code></pre><ul><li><p>上外边距：50px</p></li><li><p>右外边距：50px</p></li><li><p>下外边距：75px</p></li><li><p>左外边距：80px</p></li></ul><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><h4 id="Border-1"><a href="#Border-1" class="headerlink" title="Border"></a>Border</h4><p><code>Border</code>(边框),边框有三个要素：粗细、线型、颜色。</p><h4 id="Border属性"><a href="#Border属性" class="headerlink" title="Border属性"></a>Border属性</h4><h5 id="Border-style"><a href="#Border-style" class="headerlink" title="Border-style"></a>Border-style</h5><p>边框的线型：</p><p>![@8HSU_4Y1RAJG_NN`2_HRVV.png](<a href="https://i.loli.net/2021/11/28/sjJYm5oLdMGpCO2.png">https://i.loli.net/2021/11/28/sjJYm5oLdMGpCO2.png</a>)</p><h5 id="Border-width"><a href="#Border-width" class="headerlink" title="Border-width"></a>Border-width</h5><p>属性制定四个边框的宽度。宽度设置依然是以px,pt,cm,em等长度进行计算。不过增加了以下三个预定值：<code>thin</code>,<code>medium</code>,<code>thick</code>。</p><p>同样边框的宽度也可以四条分别设定。</p><h5 id="Border-color"><a href="#Border-color" class="headerlink" title="Border-color"></a>Border-color</h5><p>属性设置四个边框的颜色。和<code>background</code>一样可以使用：<code>name(制定颜色名)</code>,<code>HEX(#fffff)</code>,<code>RGB(255,0,0)</code>等方式进行设定。</p><p>每一条边框的颜色也是可以单独进行设置的。</p><h4 id="Border的简写属性"><a href="#Border的简写属性" class="headerlink" title="Border的简写属性"></a>Border的简写属性</h4><pre><code class="css">border: 5px solid black;</code></pre><p><img src="https://i.loli.net/2021/11/28/gMaqsyNEoXUCiW5.png" alt="_H_5UBE47XTRO7497_GW_5K.png"></p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><h4 id="Padding-1"><a href="#Padding-1" class="headerlink" title="Padding"></a>Padding</h4><p><code>Padding</code>定义了元素边框与元素内容之间的空间。</p><p>填充也可以选择单一方向进行填充。</p><ul><li><p><code>padding-top</code></p></li><li><p><code>padding-right</code></p></li><li><p><code>padding-bottom</code></p></li><li><p><code>padding-left</code></p></li></ul><p>值：</p><ul><li><p><code>length</code> - 定义一个固定的填充以px,pt,cm等单位制定。</p></li><li><p><code>%</code> - 定义一个百分比的填充</p></li></ul><h4 id="Padding的简写属性"><a href="#Padding的简写属性" class="headerlink" title="Padding的简写属性"></a>Padding的简写属性</h4><pre><code class="css">padding:25px 30px 50px 100px;</code></pre><ul><li><p>上填充：25px</p></li><li><p>右填充：30px</p></li><li><p>下填充：50px</p></li><li><p>左填充：100px</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/11/22/css-background/"/>
      <url>/2021/11/22/css-background/</url>
      
        <content type="html"><![CDATA[<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a><code>background-color</code></h3><p>css,颜色通常有以下方式表示：</p><ul><li><p>颜色名称</p></li><li><p>RGB</p></li><li><p>十六进制</p></li><li><p>RGBA</p></li></ul><pre><code class="css">background-color:red;background-color:rgb(255,0,0);background-color:#ff0000;background-color:rgba(255,0,0,0.6);</code></pre><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a><code>background-image</code></h3><p>css中可以通过<code>background-image</code>属性添加背景图片，不同的背景图片用逗号隔开。</p><pre><code class="css">background-image:url(background_img.jpg);</code></pre><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><ul><li><p>线性渐变</p></li><li><p>径向渐变</p></li></ul><p>线性渐变</p><pre><code class="css">/*从上到下，绿色渐变到红色*/background-image:linear-gradient(green,red);/*以45度轴为渐变轴，从绿色渐变到红色*/background-image:linear-gradient(45deg,green,red);/*从左下到右上，从绿色渐变到红色*/background-image:linear-gradient(to right top,green,red);</code></pre><p>实例：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a64ed2547ef779afc6d778dbd9c54812.png" alt="image.png"></p><p>径向渐变</p><pre><code class="css">background-image:radial-gradient(shape size at position,start-color,···,last-color);</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ea5e8600c4c0ee8c00232510d72c094a.png" alt="a.png"></p><pre><code class="css">/*颜色节点不均匀分布*/background-image:radial-gradient(red 5%,green 15%,blue 60%);/*圆形径向渐变*/background-image:radial-gradient(circle,red,yellow,green);/*更多*/background-image: radial-gradient(closest-side at 60% 55%, blue, green, yellow, black);background-image: radial-gradient(farthest-side at 60% 55%, blue, green, yellow, black);}</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/d8965272641607f16b4d23b6a799c289.png" alt="q.png"></p><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a><code>background-repeat</code></h3><p><code>background-repeat:no-repeat;</code>设置背景图片的平铺属性，默认为平铺满。</p><ul><li><p>repeat</p></li><li><p>no-repeat</p></li><li><p>repeat-x</p></li><li><p>repeat-y</p></li></ul><p>(1)<code>repeat</code></p><pre><code class="css">background-image:repeat:repeat;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/1d79a8cbda8c2d4fd6601b48c8c949e6.png" alt="_83MFW_B__1Q6AIRGQW7FP5.png"></p><p>(2)<code>no-repeat</code></p><pre><code class="css">background-image:repeat:no-repeat;</code></pre><p><img src="https://i.loli.net/2021/11/16/IywbjX8196m5VJH.png" alt="9_`OX~XMZ8_YG`7E_QS_7~V.png"></p><p>(3)<code>repeat-x</code></p><pre><code class="css">background-image:repeat:repeat-x;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/65d10dee6b9db6f86f0114d08e935263.png" alt="GH~YPYDN}~EZPB@AF4H_PDV.png"></p><p>(4)<code>repeat-y</code></p><pre><code class="css">background-image:repeat:repeat-y;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/04d526170454d84c4151639ca8d264b0.png" alt="9eOyYpB15WESNJs.png"></p><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a><code>background-attachment</code></h3><p><code>background-attachment:scroll;</code>设置指定背景图像是否固定。</p><ul><li><p><code>fixed</code>(背景固定，不会滚动)</p></li><li><p><code>scroll</code>(背景会随页面其余部分一起滚动)</p></li></ul><p>(1)fixed</p><pre><code class="css">background-attachment:fixed;</code></pre><p><img src="https://i.loli.net/2021/11/28/9Nj4yieU2CXQnIc.png" alt="2c03e6da31e29182b435dca07e572686.png"></p><p>(2)scroll</p><pre><code>background-attachment:scroll;</code></pre><p><img src="https://i.loli.net/2021/11/28/8qUtifzo4uJrQHx.png" alt="d3171e6e27525c3a94345e7d79f987f5.png"></p><h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a><code>background-position</code></h3><p><code>background-position</code> 属性设置背景图像定位。</p><p><strong>提示：</strong>您需要把 <code>background-attachment</code> 属性设置为 “fixed”，才能保证该属性在 Firefox 和 Opera 中正常工作.</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ba8ab0a046080f2e303fd876099eb0b.png" alt="BW~DK5304XCOH(AGO(L{S36.png"></p><pre><code>background-position:200px,600px;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/7bf4d737c1061261609fbe7bd26f473b.png" alt="Q_9VNWPC_@21_WRSA_QDN8V.png"></p><pre><code class="css">background-position:center;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/fe09d9b154eed37cbfb2a80487faaf73.png" alt="QE_6FSXKYR~TB803QA_Z6MM.png"></p><h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a><code>background-origin</code></h3><p><code>background-origin</code> 属性指定<code>background-position</code>属性应该是相对于什么位置来定位。</p><ul><li><p><code>padding-box</code></p><p>背景相对于padding进行定位。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f41ef8a74dc0a98a9a68804b3dc9b48.png" alt="5S_3A~V_S9_Z6TKWXDU0BI8.png"></p></li><li><p><code>border-box</code></p><p>背景相对于边框进行定位。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/737272e269342acf63bb0b6e2931eb54.png" alt="image.png"></p></li><li><p><code>content-box</code></p><p>背景相对于内容盒子进行定位。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c37cb17dc6c654add9e7db776fc095ad.png" alt="image.png"></p><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a><code>background-clip</code></h3><p><code>background-clip</code> 规定背景的绘制区域。(与background-origin 不同的是 background-clip)</p><ul><li><code>border-box</code></li></ul><p>从边框开始显示超出<code>border-box</code> 的部分将裁剪掉。</p><ul><li><code>padding-box</code></li></ul><p>从内边距开始显示超出<code>padding-box</code> 的部分将裁剪掉。</p><ul><li><code>content-box</code></li></ul><p>从内容区域开始显示超出<code>content-box</code> 的部分将裁剪掉。</p><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a><code>background-size</code></h3><p><code>background-size</code>规定背景图片的尺寸大小。(本实例图片大小为465*465给定盒子大小为 500 * 600)。</p><ul><li><code>length</code></li></ul><p>设置背景图片高度和宽度。第一个值设置宽度，第二个值设置高度。如果只给出一个值，第二个则自动设置为auto。</p><pre><code class="css">background-size: 250px 250px;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/b92bd84859dc53a810572017468bf8a8.png" alt="image.png"></p><ul><li><code>percentage</code></li></ul><p>将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置高度。如果只给出一个值，第二个则自动设置为auto。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f8cfcdf4a856c09c33310d1188d921c.png" alt="image.png"></p><ul><li><code>cover</code></li></ul><p>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c62eb461ebe2a3ca5aedb510479fb64f.png" alt="image.png"></p><ul><li><code>contain</code></li></ul><p>保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca7fb93182278bf9f8db5ea71a82fa01.png" alt="image.png"></p><ul><li><code>cover</code></li></ul><p>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c62eb461ebe2a3ca5aedb510479fb64f.png" alt="image.png"></p><ul><li><code>contain</code></li></ul><p>保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca7fb93182278bf9f8db5ea71a82fa01.png" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（有符号数）</title>
      <link href="/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%EF%BC%89%EF%BC%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%89/"/>
      <url>/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%EF%BC%89%EF%BC%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h2 id="计算机组成原理（有符号数）"><a href="#计算机组成原理（有符号数）" class="headerlink" title="计算机组成原理（有符号数）"></a>计算机组成原理（有符号数）</h2><p><font color="#999AAA">原码、反码、补码以及移码问题，总是忘。其实都是很简单的规律。<img src="https://img-blog.csdnimg.cn/4966bfd9cf724d1da785c72017c471cc.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FfY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/80db298ed06645ca8e7e2a23b7195922.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FfY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></font></p><font color="#999AAA"></font>]]></content>
      
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2021/08/04/Makefile/"/>
      <url>/2021/08/04/Makefile/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">Makefile是一个文本文件，是GUN make 程序执行时默认读取配置的文件。</font></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="一、Makefile的工作原理"><a href="#一、Makefile的工作原理" class="headerlink" title="一、Makefile的工作原理"></a>一、Makefile的工作原理</h1><pre><code class="powershell">{目标文件}：{依赖文件1}{依赖文件2}···    {命令1}    {命令2}       ·       ·       ·</code></pre><p>通过一个或多个依赖文件执行成一个目标文件。并且依赖文件之间可以相互嵌套。</p><h1 id="二、使用Makefile"><a href="#二、使用Makefile" class="headerlink" title="二、使用Makefile"></a>二、使用Makefile</h1><h2 id="1-编写5个-c文件和4个-h文件"><a href="#1-编写5个-c文件和4个-h文件" class="headerlink" title="1.编写5个.c文件和4个.h文件"></a>1.编写5个.c文件和4个.h文件</h2><p>1.c</p><pre><code class="c">include&lt;stdio.h&gt;#include"1.h"int test_1(){        printf("test_1.......\n");        return 0;}</code></pre><p>1.h</p><pre><code class="c">int test_1();</code></pre><p>2.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"2.h"int test_2(){        printf("test_2.......\n");        return 0;}</code></pre><p>2.h</p><pre><code class="c">int test_2();</code></pre><p>3.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"3.h"int test_3(){        printf("test_3.....\n");        return 0;}</code></pre><p>3.h</p><pre><code class="c">int test_3();</code></pre><p>4.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"4.h"int test_4(){        printf("test_4.....\n");        return 0;}</code></pre><p>4.h</p><pre><code class="c">int test_4();</code></pre><p>5.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"1.h"#include"2.h"#include"3.h"#include"4.h"int main(){        test_1();        test_2();        test_3();        test_4();        return 0;}</code></pre><h2 id="2-创建编写Makefile文件"><a href="#2-创建编写Makefile文件" class="headerlink" title="2.创建编写Makefile文件"></a>2.创建编写Makefile文件</h2><pre><code class="c">Main:1.o 2.o 3.o 4.o 5.o        gcc 5.c 4.c 3.c 2.c 1.c -o Main1.o:1.c 1.h        gcc -c 1.c2.o:2.c 2.h        gcc -c 2.c3.o:3.c 3.h        gcc -c 3.c4.o:4.o 4.h        gcc -c 4.c5.o:5.c 1.h 2.h 3.h 4.h        gcc -c 5.cclean:        rm Main 1.o 2.o 3.o 4.o 5.o</code></pre><p>Main为目标文件，*.o文件是他的依赖文件。通过gcc5个.c文件生成可执行文件Main</p><p>1.o是目标文件，1.c和1.h是他的依赖文件。通过gcc 1.c生成1.o文件。下同。<br>最后是Makefile的clean规则，在当前目录下输入make clean再次查看目录会发现可执行文件Main和*.o文件没有了。</p><h2 id="3-make"><a href="#3-make" class="headerlink" title="3.make"></a>3.make</h2><p>在目录下输入make后生成可执行文件Main，执行该文件。</p><p><img src="https://img-blog.csdnimg.cn/20210416205035570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">Makefile可以完美解决每次编译程序的时候都要输入完整的命令和编译文件名以及参数的问题。省去了繁杂的编译命令，节省了时间。</font></p><font color="#999AAA"></font>]]></content>
      
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--v-指令</title>
      <link href="/2021/08/04/Vue%E4%B9%8Bv-%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/08/04/Vue%E4%B9%8Bv-%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="v-指令"><a href="#v-指令" class="headerlink" title="v-指令"></a>v-指令</h1><h2 id="1-v-text"><a href="#1-v-text" class="headerlink" title="1.v-text"></a>1.v-text</h2><p><font color="#999AAA">v-text指令的作用是设置内容的标签，设置文本。数据定义在data中。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-text="message"&gt;&lt;/h2&gt;        &lt;h2 v-text="message2"&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "learn",                message2: "hello"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="2-v-html"><a href="#2-v-html" class="headerlink" title="2.v-html"></a>2.v-html</h2><p><font color="#999AAA">v-html指令的作用是设置innerHTML标签。与v-text不同于v-text只解析为文本。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;p v-html="content"&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                content: "&lt;a href='https://www.csdn.net/'&gt;CSDN&lt;/a&gt;"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="3-v-on"><a href="#3-v-on" class="headerlink" title="3.v-on"></a>3.v-on</h2><p><font color="#999AAA">事件绑定用于监听DOM事件，绑定的方法定义在methods中。v-on还可以简写为@。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;input type="button" value="v-on指令" v-on:click="one"&gt;        &lt;input type="button" value="v-on简写" @dblclick="two"&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            methods: {                one: function() {                    alert("单击了一下");                },                two: function() {                    alert("双击666");                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="4-v-if-v-show"><a href="#4-v-if-v-show" class="headerlink" title="4.v-if/v-show"></a>4.v-if/v-show</h2><p><font color="#999AAA">在指令条件表达式返回值为true是进行渲染</font></p><font color="#999AAA"><p>v-show<br><font color="#999AAA">通过控制样式的display属性，渲染的元素始终保留在DOM中。如果运行的条件很少改变可以选择使用v-show指令。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-show="isShow"&gt;show hello&lt;/h2&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isShow: true            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>v-if<br><font color="#999AAA">会根据条件来决定条件块内监听器和组件的销毁和重建。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-if="temp === 'a'"&gt;看见了1&lt;/h2&gt;        &lt;h2 v-else-if="temp === 'b'"&gt;看见了2&lt;/h2&gt;        &lt;h2 v-else="temp === 'c'"&gt;看见了3&lt;/h2&gt;        &lt;input type="button" value="next" @click="change1" @dblclick="change2"&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                temp: "a"            },            methods: {                change1: function() {                    this.temp = 'b';                },                change2: function() {                    this.temp = 'c';                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="5-v-bind"><a href="#5-v-bind" class="headerlink" title="5.v-bind"></a>5.v-bind</h2><p><font color="#999AAA">元素绑定，操作元素属性的指令。</font></p><font color="#999AAA"><p>v-bind:class<br><font color="#999AAA">根据条件执行class列表内容，来动态的操作class。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div v-bind:class="{active:isActive}" style="width:200px;height: 200px;text-align: center;line-height: 200px;"&gt;v-bind&lt;/div&gt;        &lt;!-- &lt;div class="static" v-bind:class="active:isActive,'text-danger" :hasError&gt;&lt;/div&gt;        &lt;div class="static active"&gt;&lt;/div&gt; --&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isActive: true,                // hasError: false            },        })    &lt;/script&gt;    &lt;style&gt;        .active {            background-color: #ff0000;        }    &lt;/style&gt;&lt;/body&gt;</code></pre><p>v-bind:style<br><font color="#999AAA">操作元素的内联样式</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div v-bind:style="isStyle"&gt;v-bind&lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isStyle: {                    height: '100px',                    width: '100px',                    fontsize: '20px',                    color: 'red',                    background: 'black',                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="6-v-for"><a href="#6-v-for" class="headerlink" title="6.v-for"></a>6.v-for</h2><p><font color="#999AAA">响应式的根据数据生成列表结构</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div&gt;v-for            &lt;ul&gt;                &lt;li v-for="item in arr"&gt;                    {{ item }}                &lt;/li&gt;            &lt;/ul&gt;            &lt;h2 v-for="(item,index) in str"&gt;                {{ acc }} - {{ index }} - {{ item }}            &lt;/h2&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                arr: ["a", "b", "c", "d"],                str: ["one", "two", "tree"],                acc: "time"            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="7-v-model"><a href="#7-v-model" class="headerlink" title="7.v-model"></a>7.v-model</h2><p><font color="#999AAA">表单元素双向绑定，绑定的数据与表单元素值相关联。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        v-model        &lt;input type="text" v-model="message"&gt;        &lt;h2&gt; {{ message }} &lt;/h2&gt;    &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "123"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。–就是好用就完了。</font></p><font color="#999AAA"></font></font></font></font></font></font></font></font></font></font></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--创建第一个项目</title>
      <link href="/2021/08/04/vue--%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/04/vue--%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">vue作为前端三大框架之一，对于前端开发非常重要。</font></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="一、vue是什么？"><a href="#一、vue是什么？" class="headerlink" title="一、vue是什么？"></a>一、vue是什么？</h1><p><font color="#999AAA">Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</font></p><font color="#999AAA"><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-创建一个vue项目"><a href="#1-创建一个vue项目" class="headerlink" title="1.创建一个vue项目"></a>1.创建一个vue项目</h2><p><font color="#999AAA">可以通过vue CLI<br>vue create 进行创建</font></p><font color="#999AAA"><pre><code class="powershell">vue create hello-word</code></pre><p>也可以通过图形化界面创建</p><pre><code class="powershell">vue ui</code></pre><p>会进入一个浏览器窗口，可以再窗口中进行项目的创建、配置等。<br><img src="https://img-blog.csdnimg.cn/20210416150312629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-项目的运行"><a href="#2-项目的运行" class="headerlink" title="2.项目的运行"></a>2.项目的运行</h2><p><font color="#999AAA">在终端中输入命令</font></p><font color="#999AAA"><p>如果是使用yarn使用</p><pre><code class="powershell">yarn serve</code></pre><p>使用npm就是</p><pre><code class="powershell">npm serve</code></pre><p>项目运行起来就可以在终端打开<br><img src="https://img-blog.csdnimg.cn/20210416150936956.png" alt="在这里插入图片描述"><br>点开URL就看到<br><img src="https://img-blog.csdnimg.cn/20210416151141332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">从头开始，这就是第一个vue项目。</font></p><font color="#999AAA"></font></font></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--&#39;el&#39;</title>
      <link href="/2021/07/11/Vue--%E2%80%98el%E2%80%98%E6%8C%82%E8%BD%BD/"/>
      <url>/2021/07/11/Vue--%E2%80%98el%E2%80%98%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1.png" alt="avatar"></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;">将DOM组件渲染塞入页面的过程<font color="#999AAA"></font><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><font color="#999AAA"><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;el:挂载点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        {{ message }}    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "挂载！"            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><font color="#999AAA">el命中挂载的元素内部可以通过Vue管理。</font></p><font color="#999AAA"><h2 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h2><p>通常使用id选择器因为通常id选择器是唯一的，而类选择器等都可用于多个元素容易造成语意不清而混乱。</p><h2 id="2-挂载标签"><a href="#2-挂载标签" class="headerlink" title="2.挂载标签"></a>2.挂载标签</h2><p>可以挂载到除和以外大多数双标签上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>挂载也是使用Vue的重要的一步。</p></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
