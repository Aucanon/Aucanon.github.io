<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指 Offer 10- I. 斐波那契数列</title>
      <link href="/2023/02/23/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2023/02/23/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><pre><code>F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 5输出：5</code></pre><pre><code>/** * @param {number} n * @return {number} */var fib = function(n) {    const MOD = 1000000007    if (n &lt; 2) return n    var p = 0, q = 0, r = 1    for (var i = 2; i &lt;= n; i++) {        p = q        q = r        r = (p + q) % MOD    }    return r};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer II 038. 每日温度</title>
      <link href="/2023/02/19/%E5%89%91%E6%8C%87%20Offer%20II%20038.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/2023/02/19/%E5%89%91%E6%8C%87%20Offer%20II%20038.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><pre><code>输入: temperatures = [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: temperatures = [30,40,50,60]输出: [1,1,1,0]</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: temperatures = [30,60,90]输出: [1,1,0]</code></pre><pre><code>// 单调栈/** * @param {number[]} temperatures * @return {number[]} */var dailyTemperatures = function(temperatures) {    // 存储温度对应索引位置（用于记录天数）    var stack = [0]    var count = 1    // 结果 （默认结果数组使用 0 填充）    var len = temperatures.length    var arr = new Array(len).fill(0)    for (var i = 0;i &lt; len; i++) {        let temp = temperatures[i]        // 使用temp 比较栈顶值 如果栈顶值小 进行出栈（计算日期差，并存储）并重复        // stack[count - 1]代表栈顶值        while(count &amp;&amp; temp &gt; temperatures[stack[count - 1]]) {            // 出栈            var index = stack.pop()            count--            // 计算index 和 i 的差 作为 index位置的升温日期的天数            arr[index] = i - index        }        // 处理完 当前温度入栈（等待找到后序更大的温度）        stack.push(i)        count++    }    return arr};</code></pre><pre><code>// 暴力/** * @param {number[]} temperatures * @return {number[]} */var dailyTemperatures = function(temperatures) {    var len = temperatures.length    var arr = new Array(len).fill(0)    for(var i = 0; i &lt; len; i++) {        for (var j = i + 1; j &lt; len; j++) {            if (temperatures[i] &lt; temperatures[j]) {                arr[i] = j - i                break            }        }    }    return arr};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 09. 用两个栈实现队列</title>
      <link href="/2023/02/18/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2023/02/18/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><pre><code>输入：["CQueue","appendTail","deleteHead","deleteHead","deleteHead"][[],[3],[],[],[]]输出：[null,null,3,-1,-1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]</code></pre><pre><code>var CQueue = function() {    this.stackIn = []    this.stackOut = []};/**  * @param {number} value * @return {void} */CQueue.prototype.appendTail = function(value) {    // 进栈    this.stackIn.push(value)};/** * @return {number} */CQueue.prototype.deleteHead = function() {    // 出栈    if (this.stackOut.length) {        return this.stackOut.pop()    } else {        // 把stackIn的值调换顺序推入stackOut        while (this.stackIn.length) {            this.stackOut.push(this.stackIn.pop())        }        return this.stackOut.pop() || -1    }};/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 30. 包含min函数的栈</title>
      <link href="/2023/02/18/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2023/02/18/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.</code></pre><pre><code>/** * initialize your data structure here. */var MinStack = function() {    this.stack = []    // 存储最小值的栈    this.minStack = [Infinity]};/**  * @param {number} x * @return {void} */MinStack.prototype.push = function(x) {    this.stack.push(x)    // 判断新值和minStack栈顶的值大小    this.minStack.push(Math.min(this.minStack[this.minStack.length - 1], x))};/** * @return {void} */MinStack.prototype.pop = function() {    this.stack.pop()    this.minStack.pop()};/** * @return {number} */MinStack.prototype.top = function() {    return this.stack[this.stack.length - 1]};/** * @return {number} */MinStack.prototype.min = function() {    return this.minStack[this.minStack.length - 1]};/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 07. 重建二叉树</title>
      <link href="/2023/02/17/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/02/17/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p> <img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><p><strong>示例 1:</strong></p><pre><code>---title: backgrounddate: 2021-11-22tags: CSScover: ---Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]</code></pre><p><strong>示例 2:</strong></p><pre><code>Input: preorder = [-1], inorder = [-1]Output: [-1]</code></pre><pre><code>/** * Definition for a binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */var buildTree = function(preorder, inorder) {    // 判断    if(!preorder.length || !inorder.length) return null    // 根据前序遍历（根左右）preorder[0]就是根节点    const rootnode = preorder[0]    // 中序遍历（左根右）可以找到根节点下标，对其左右进行划分    const rootnodeIndex = inorder.indexOf(rootnode)    // 创建二叉树    const node = new TreeNode(rootnode)    // preorder[0]为根节点，+1就是左区的根节点    // inorder根节点位置为rootnodeIndex他左边的即为左区根节点    node.left = buildTree(preorder.slice(1, rootnodeIndex + 1), inorder.slice(0, rootnodeIndex))    node.right = buildTree(preorder.slice(rootnodeIndex + 1), inorder.slice(rootnodeIndex + 1))    return node};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5中getOptions没了？</title>
      <link href="/2022/11/18/webpack5%E4%B8%ADgetOptions%E6%B2%A1%E4%BA%86%EF%BC%9F/"/>
      <url>/2022/11/18/webpack5%E4%B8%ADgetOptions%E6%B2%A1%E4%BA%86%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>﻿<br>在做一个webpack的demo的时候创建一个自定义的<code>loader</code>,对loader进行配置的时候设置了<code>size:20</code>，看的教程以及别的教程的博客都是用的<code>getOptions</code>方法来获取options的配置项。</p><pre><code class="javascript">{   test:/\.md$/i,    // use:'./loader/markdown-loader'    use:[        'html-loader',        //marked将md转换为html        // './loader/markdown-loader'        {            loader:'./loader/markdown-loader',            options:{                size:20            }        }    ]}</code></pre><pre><code class="javascript">const loaderUtils = require('loader-utils')module.exports = function(source) {    //获取loader配置项    const options = loaderUtils.getOptions(this)    console.log('ooooo' + options);    const html = marked.parse(source)    return html}</code></pre><p>但是现在使用这个方法进行打包的时候就会报没有getOptions方法的错误。</p><p><img src="https://img-blog.csdnimg.cn/e2d91fdb0dd74ad5b6581d1489da1dd9.png" alt="在这里插入图片描述"><br>在官方文档中方法好像只剩下了</p><p><img src="https://img-blog.csdnimg.cn/6eaa04d300b04bf08c59060c42fbfd5d.png" alt="请添加图片描述"><br>但是好像没有替换的方法，后来注意到方法 interpolateName 的参数中有一个<code>query</code>的参数然后就直接拿来试了一下。<br><img src="https://img-blog.csdnimg.cn/8c59441d0cb34082b4795ea4c1bf7c32.png" alt="在这里插入图片描述"></p><pre><code class="javascript">module.exports = function(source) {    //获取loader配置项    // const options = this.query    console.log('ooooo' + this.query.size);    console.log('123'+source);    const html = marked.parse(source)    return html}</code></pre><p>确实能够输出配置的 <code>size:20</code></p><p><img src="https://img-blog.csdnimg.cn/e310542a78ed4e6f8f5eab3029aebb0a.png" alt="在这里插入图片描述"><br>虽然不知道是不是正解，但是目前就是好像可以拿到配置的options了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基本使用</title>
      <link href="/2022/11/16/webpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/16/webpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><blockquote><p>Webpack = Web Package<br>webpack 是⼀个模块打包器（Module bundler）。它的主要⽬标是将 JS ⽂件打包在⼀起，<br>打包后的⽂件⽤于在浏览器中使⽤。同时，它也能够转换 (transform)、打包(bundle) 或包<br>裹 (package) 任何资源。</p></blockquote><p>功能：</p><blockquote><ul><li>将多个⽂件合并（打包），减少 HTTP 请求次数，从⽽提⾼效率</li><li>对代码进⾏编译，确保浏览器兼容性</li><li>对代码进⾏压缩，减⼩⽂件体积，提⾼加载速度</li><li>检测代码格式，确保代码质量</li><li>提供热更新服务，提⾼开发效率</li><li>针对不同环境，提供不同的打包策略</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/6a5a3faa458143b99870dcf4954f813e.png" alt="在这里插入图片描述"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>默认的配置⽂件名称是 <code>webpack.config.js</code></p><blockquote><p>webpack.config.js 是以 CommonJS规范进⾏组织的</p></blockquote><p>常用基本配置：</p><pre><code class="javascript">/***webpack配置**/const { resolve } = require('path')module.exports = {    //打包模式    mode:'development',    //入口文件    entry:'./src/index.js',    //出口配置    output:{        //输出目录        path:resolve(__dirname,'output'),        //输出文件名        filename:'main.js'    },    module:{        rules:[            //指定多个配置规则        ]    },    //开发服务器    devServer:{    },    //插件配置    plugins:[        ]}</code></pre><h2 id="打包css"><a href="#打包css" class="headerlink" title="打包css"></a>打包css</h2><blockquote><ul><li>css-loader 负责遍历 CSS ⽂件，将 CSS 转化为 CommonJS（将 CSS 输出到打包后的JS ⽂件中）</li><li>style-loader 负责把包含 CSS 内容的 JS 代码，挂载到⻚⾯的 style 标签当中。</li><li>less-loader 负责将less文件编译称为 CSS 文件。</li><li>mini-css-extract-plugin 负责将CSS提取到单独的文件中。它为每个包含CSS的JS文件创建一个CSS文件。</li><li>postcss-loader autoprefixer 负责解决浏览器兼容问题添加前缀。（PostCSS 需要⼀个配置，⽤来设置autoprefixer 的设置标准（即需要指定兼容哪些浏览器））</li><li>stylelint stylelint-config-standard stylelint-webpack-plugin 负责 CSS 格式的校验</li></ul></blockquote><p>webpack.config.js:</p><pre><code class="javascript">const { resolve } = require('path')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const StyleLintPlugin = require('stylelint-webpack-plugin')const CssMiniMizer = require('css-minimizer-webpack-plugin')module.exports = {    //打包模式    mode:'development',    //入口文件    entry:'./src/index.js',    //出口配置    output:{        //输出目录        path:resolve(__dirname,'output'),        //输出文件名        filename:'main.js'    },    module:{        rules:[            //指定多个配置规则            {                test:/\.css$/i,                //use中loader的加载顺序从右到左，先下后上                use:[                    //#3.将js中的样式挂载到&lt;style&gt;标签中                    // 'style-loader',                    //3.将css打包到独立的文件中                    MiniCssExtractPlugin.loader,                    //2.css-loader按commonjs规范将样式文件输出到js中                    'css-loader',                    //1通过postcss-loader给样式属性添加浏览器前缀                    'postcss-loader'                ]            },            {                test:/\.less$/i,                //use中loader的加载顺序从右到左，先下后上                use:[                    //#4.将js中的样式挂载到&lt;style&gt;标签中                    // 'style-loader',                    //4.将css打包到独立的文件中                    MiniCssExtractPlugin.loader,                    //3.css-loader按commonjs规范将样式文件输出到js中                    'css-loader',                    //2通过postcss-loader给样式属性添加浏览器前缀                    'postcss-loader',                    //1.将less转成普通css                    'less-loader'                ]            }        ]    },    //开发服务器    devServer:{    },    //插件配置    plugins:[        new MiniCssExtractPlugin({            filename:'css/[name].css'//[name].css保留原有名字        }),        new StyleLintPlugin({            //制定需要格式校验的文件            files:['src/css/*.{css,less,sass,scss}']        }),        new CssMiniMizer({            //压缩css        })    ]}</code></pre><p>postcss.config.js:</p><pre><code class="javascript">module.exports = {    'plugins':[        require('autoprefixer')    ]}</code></pre><p>package.json（插件所需配置部分）:</p><pre><code class="javascript">"browserslist": [    "last 1 version",    "&gt; 1%"  ],  "stylelint": {    "extends": "stylelint-config-standard",    "rules": {}  }</code></pre><h2 id="打包HTML"><a href="#打包HTML" class="headerlink" title="打包HTML"></a>打包HTML</h2><blockquote><p>html-webpack-plugin 该插件⽤来创建 HTML ⽂件，创建的 HTML ⽂件默认引⼊打包后的所有资源⽂件</p></blockquote><p>引入</p><pre><code class="javascript">const HtmlWebpackPlugin = require('html-webpack-plugin')</code></pre><p>配置</p><pre><code class="javascript">plugins: [     new HtmlWebpackPlugin({        template: './src/index.html', // 指定 HTML 的模板        title:'abbbout',//指定HTML title为一个变量            minify:{                collapseWhitespace:true,                keepClosingSlash:true,                removeComments:true,                removeRedundantAttributes:true,                removeScriptTypeAttributes:true,                removeStyleLinkTypeAttributes:true,                useShortDoctype:true            }//压缩HTML代码    })  ]</code></pre><h2 id="打包JS"><a href="#打包JS" class="headerlink" title="打包JS"></a>打包JS</h2><blockquote><p>babel-loader<br>@babel/core      包含 Babel 转换的核⼼ API<br>@babel/preset-env  包含最新 JS 语法的转换规则<br>babel-loader      Webpack 中，转换 JS 的加载器</p></blockquote><p><img src="https://img-blog.csdnimg.cn/cd14f1160a854fb4aaec9f866face94e.png" alt="在这里插入图片描述"><br>配置：</p><pre><code class="javascript">const path = require('path') module.exports = {     mode: 'none',     entry: './src/main.js',     output: {         filename: 'bundle.js',         path: path.join(__dirname, 'dist'),         publicPath: 'dist/'     },     module: {         rules: [             {                 test: /\.m?js$/i,                 exclude: /node_modules/, // 排除不需要打包的⽬录                 use: {                     loader: 'babel-loader',                     options: {                     presets: ['@babel/preset-env']                     }                 }             }         ]     } }</code></pre><blockquote><p>启⽤ babel-loader 后 ES6+ 的语法会转成 ES5。但是 babel 只会对基本语法进⾏转移。像 promise<br>这样的⾼级语法，Babel 就不能转换。</p></blockquote><p>转化高级语法可以使用polyfill</p><blockquote><p>在入口文件引入  <code>import '@babel/polyfill'</code></p></blockquote><blockquote><p>@babel/polyfill 会对所有的 JS 新语法进⾏转译（没⽤到的新语法也会被转译），因此打包后的 JS 会<br>⾮常⼤</p></blockquote><p>使用core-js 可以进行按需转译</p><p>配置：</p><pre><code class="javascript">{    test: /\.m?js$/i,    exclude: /node_modules/, // 排除不需要打包的⽬录    use: {        loader: 'babel-loader',        options: {            presets: [                [                    '@babel/preset-env',                    {                        //按需加载                        useBuiltIns:'usage',                        corejs:3,                        //指定兼容浏览器版本                        targets:{                            chrome:'58',                            ie:'9',                            firefox:'60',                            edge:'17'                        }                    }                ]            ]        }    }}</code></pre><p>格式校验：<br>使⽤ eslint-webpack-plugin 来进⾏ JS 的格式校验</p><blockquote><p>eslint（⽤来对 JS 进⾏格式校验的⼯具）<br>eslint-config-airbnb-base（格式校验规则)<br>eslint-webpack-plugin（Webpack 的 eslint 插件）<br>eslint-plugin-import（ ⽤于在 package.json 中读取 eslintConfig 配置项 ）</p></blockquote><p>使用：</p><pre><code class="javascript">const ESLintPlugin = require('eslint-webpack-plugin');module.exports = {     plugins: [new ESLintPlugin(options)],};</code></pre><p>配置：</p><pre><code class="javascript">const ESLintPlugin = require('eslint-webpack-plugin');    module.exports = {        plugins: [            new ESLintPlugin({                fix: true,                extensions: ['js', 'json', 'coffee'],                exclude: '/node_modules/'            }),    ]}</code></pre><p>在 package.json 中，通过 eslintConfig 指定eslint配置</p><pre><code class="javascript">"eslintConfig": {    "extends":"airbnb-base"  }</code></pre><p>webpack打包基础的demo：<a href="https://github.com/Aucanon/learn/tree/main/Part3/M2/test/basic">https://github.com/Aucanon/learn/tree/main/Part3/M2/test/basic</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化构建工具Gulp</title>
      <link href="/2022/11/11/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gulp/"/>
      <url>/2022/11/11/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gulp/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><h1 id="Gulp基础使用"><a href="#Gulp基础使用" class="headerlink" title="Gulp基础使用"></a>Gulp基础使用</h1><p><a href="https://www.gulpjs.com.cn/">Gulp中文网</a>  在首页面就展示了基本使用的步骤。<br><img src="https://img-blog.csdnimg.cn/0c7bcd83f40d486bb31890ddcdc465d3.png" alt="在这里插入图片描述"></p><p>后面自己创建一个使用Gulp的用例。</p><p>首先全局安装Gulp客户端</p><pre><code class="powershell">npm install -g gulp-cli </code></pre><p>初始化项目</p><pre><code class="powershell">npm init --yes</code></pre><p>在项目下安装Gulp</p><pre><code class="powershell">npm install gulp -D</code></pre><p>在项目下新建一个<code>gulpfile.js</code>的Gulp入口文件。<br>在<code>gulpfile.js</code>中创建一个Gulp任务</p><pre><code class="javascript">const task1 = () =&gt; {    console.log('gulp111 tast is running');}module.exports = {    task1}</code></pre><p><img src="https://img-blog.csdnimg.cn/8d321131fd9147fc815755eafe94ca2b.png" alt="在这里插入图片描述"></p><p>该任务会虽然会执行出结果但是会有报错，因为在最新Gulp中支持的是异步任务所以在任务中应该有一个回调函数。</p><pre><code class="javascript">const task1 = (callback) =&gt; {    console.log('gulp111 tast is running');    callback()}module.exports = {    task1}</code></pre><p><img src="https://img-blog.csdnimg.cn/3a77769bbc364f2e804030ecba383182.png" alt="在这里插入图片描述"><br>在任务中还可以配置默认执行任务项，执行gulp命令时就可以不用输入人物名。</p><pre><code class="javascript">const task1 = (callback) =&gt; {    console.log('gulp111 tast is running');    callback()}const task2 = (callback) =&gt; {    console.log('gulp222 tast is running');    callback()}module.exports = {    default:task1,    task2    }</code></pre><p><img src="https://img-blog.csdnimg.cn/da5360aa33b54828a204e116b624f91d.png" alt="在这里插入图片描述"></p><h1 id="Gulp组合任务"><a href="#Gulp组合任务" class="headerlink" title="Gulp组合任务"></a>Gulp组合任务</h1><p>组合式任务可以分为并行执行和串行执行两种方式。</p><p><img src="https://img-blog.csdnimg.cn/b766d99cb320406c93741639eb300b6a.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/eaac834105a6423e9aadf0df6373aad5.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8cedaf05e90e4eff8028604b8dcda0f9.png" alt="在这里插入图片描述"></p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><pre><code class="javascript">const gulp = require('gulp')const task1 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task1 is running');        callback()    },1000)}const task2 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task2 is running');        callback()    },1000)}const task3 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task3 is running');        callback()    },1000)}exports.p = gulp.parallel(task1,task2,task3)</code></pre><p><img src="https://img-blog.csdnimg.cn/a8cd0834409649a39ba44f11af229df3.png" alt="在这里插入图片描述"></p><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><pre><code class="javascript">const gulp = require('gulp')const task1 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task1 is running');        callback()    },1000)}const task2 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task2 is running');        callback()    },1000)}const task3 = (callback) =&gt; {    setTimeout(() =&gt; {        console.log('task3 is running');        callback()    },1000)}exports.s = gulp.series(task1,task2,task3)</code></pre><p><img src="https://img-blog.csdnimg.cn/9df023f282844d699afea72de2575f57.png" alt="在这里插入图片描述"></p><p>组合任务就可以随意将任务进行排列组合进行执行。</p><h1 id="Gulp文件操作"><a href="#Gulp文件操作" class="headerlink" title="Gulp文件操作"></a>Gulp文件操作</h1><h3 id="构建样式文件"><a href="#构建样式文件" class="headerlink" title="构建样式文件"></a>构建样式文件</h3><p>   Gulp是基于<code>流</code> 的构建系统，所以Gulp的文件操作也是以<code>流</code>的方式。</p><p><img src="https://img-blog.csdnimg.cn/cd8fc770dffd4e3db76ffd47e2efa3e7.png" alt="在这里插入图片描述"></p><blockquote><p>src：拿到输入的内容</p></blockquote><blockquote><p>pipe：管道</p></blockquote><blockquote><p>dest：目标</p></blockquote><p><img src="https://img-blog.csdnimg.cn/cb8fe53d06eb48b5a0ed8cacefad610a.png" alt="在这里插入图片描述"></p><p>实现将less文件转换为css样式文件并且进行压缩后重命名操作。</p><p><img src="https://img-blog.csdnimg.cn/b2fb1e359da74c76bac3fe2d2929752f.png" alt="在这里插入图片描述"></p><p>Gulp插件可以在 <a href="https://gulpjs.com/plugins">Gulp官网插件查询</a> 或者在 <a href="https://www.npmjs.com/">npm官网</a> 查找安装。</p><pre><code class="javascript">const {src,dest} = require('gulp')const less = require('gulp-less')const cleancss = require('gulp-clean-css')const rename = require('gulp-rename')const autoprefixer = require('gulp-autoprefixer')const style = () =&gt; {    return src('src/style/index.less',{base:'src'})   //第二个参数为文件目录格式以src样式为准    .pipe(less())   //less转化css    .pipe(autoprefixer())   //解决兼容性问题    .pipe(cleancss())   //将css代码进行格式化压缩    .pipe(rename({'extname':'.min.css'}))    //将文件进行重新命名    .pipe(dest('dist'))}module.exports = {    style}</code></pre><p><img src="https://img-blog.csdnimg.cn/ee7509e49d8640b0839d756283477d28.png" alt="在这里插入图片描述"><br>文件目录：<br><img src="https://img-blog.csdnimg.cn/b0371ca9c77549569cf295680c2bbed4.png" alt="在这里插入图片描述"></p><h3 id="构建脚本文件"><a href="#构建脚本文件" class="headerlink" title="构建脚本文件"></a>构建脚本文件</h3><p><img src="https://img-blog.csdnimg.cn/a081fa613f2a490391a25a397702eca5.png" alt="在这里插入图片描述"></p><p>安装构建js文件所需插件</p><p><img src="https://img-blog.csdnimg.cn/3d48d207e5d14baa82049a01677bc031.png" alt="在这里插入图片描述"></p><pre><code class="javascript">const {src,dest} = require('gulp')const rename = require('gulp-rename')const babel = require('gulp-babel');const uglify = require('gulp-uglify')const script = () =&gt; {    return src('src/js/index.js',{base:'src'})  //第二个参数为文件目录格式以src样式为准    .pipe(babel({        presets: ['@babel/env']    }))     //代码格式化    .pipe(uglify())     //代码压缩    .pipe(rename({'extname':'.min.js'}))    //重命名    .pipe(dest('dist'))}module.exports = {    script}</code></pre><p><img src="https://img-blog.csdnimg.cn/db2266d4e17a410aa99e429c56bf0310.png" alt="在这里插入图片描述"><br>文件目录<br><img src="https://img-blog.csdnimg.cn/010ac2021551499c80f6b4ab495fbef7.png" alt="在这里插入图片描述"></p><h3 id="构建结构文件"><a href="#构建结构文件" class="headerlink" title="构建结构文件"></a>构建结构文件</h3><p><img src="https://img-blog.csdnimg.cn/efb6bff713544d28be613b5b8af45919.png" alt="在这里插入图片描述"></p><pre><code class="javascript">const {src,dest} = require('gulp')const htmlmin = require('gulp-htmlmin')const html = () =&gt; {    return src('src/index.html')    .pipe(htmlmin({        collapseWhitespace:true,        minifyCSS:true,        minifyJS:true    }))   //格式化html文件    .pipe(dest('dist'))}module.exports = {        html}</code></pre><p><img src="https://img-blog.csdnimg.cn/4d4ee578f38947c89adf76f87fc1e8e1.png" alt="在这里插入图片描述"></p><p>文件目录</p><p><img src="https://img-blog.csdnimg.cn/b92a779dc3224a4aa4f1b8671e26d380.png" alt="在这里插入图片描述"></p><h3 id="组合构建"><a href="#组合构建" class="headerlink" title="组合构建"></a>组合构建</h3><p>可以在Gulp中引入<code>parallel</code>方法进行异步构建。</p><pre><code class="javascript">const build = parallel(style,script,html)</code></pre><p><img src="https://img-blog.csdnimg.cn/02343141b1fa4f53859dd2925f59035e.png" alt="在这里插入图片描述"></p><p>可以实现同样的效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js的7种继承方法</title>
      <link href="/2022/11/02/JS%E7%9A%847%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/"/>
      <url>/2022/11/02/JS%E7%9A%847%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承的object方法本质上是对参数对象的一个浅复制。<br>ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的函数A方法效果相同。</p><pre><code class="javascript">    function object(o){        function F(){};        F.prototype = o;        return new F();      }    var person = {        name:"zs",        friends:["ls","ww"]      };    var person1 = object(person);    person1.name = "xm";    person1.friends.push("xz");      var person2 = object(person);    person2.name = "ll";    person2.friends.push("lx");    console.log("person1:" + person1.name);    console.log("person2:" + person2.name)    console.log("person1 friends:" + person1.friends);    console.log("person2 friends:" + person2.friends);    console.log("all friends:" + person.friends);</code></pre><p><img src="https://img-blog.csdnimg.cn/5eae36d17c9440ccb25b40246e0dfc5c.png" alt="在这里插入图片描述"></p><p>优点：不需要单独创建构造函数。</p><p>缺点：子类创建实例时不能向父类传递参数，属性中包含的引用值始终会在相关对象间共享。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>将父类的实例作为子类的原型</p><pre><code class="javascript">    // 人类类型    function Person(name,age,sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    // 学生类型    function Student(score) {            this.score = score;    }    // 老师类型    function Teacher(salary) {      this.salary = salary;    }    // 原型对象，可以将自己的属性和方法继承给将来的实例对象使用    Student.prototype = new Person("zs",18,"男");    Student.prototype.constructor = Student;    // 生成一个实例    var s1 = new Student(89);    var s2 = new Student(100);    console.dir(s1);    console.dir(s2); </code></pre><p><img src="https://img-blog.csdnimg.cn/9e2e6dff5c434bcfa7d838107251c663.png" alt="在这里插入图片描述"></p><p>优点：写法简单容易理解。</p><p>缺点：父类的引用属性会被子类实例共享，子类创建实例时不能向父类传递参数。</p><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>使用call()或apply()方法将父类对象的构造函数绑定在子对象上。</p><pre><code class="javascript">    // 人类类型    function Person(name,age,sex) {      this.name = name;      this.age = age;      this.sex = sex;    }    // 学生类型    function Student(name,age,sex,score) {      // 直接对父类型的构造函数进行一个普通调用      // Person 普通调用过程中，内部的 this 指向的是 window      // 可以通过 call 方法更改Person 内部的 this      Person.call(this,name,age,sex);       this.score = score;    }    // 老师类型    function Teacher(name,age,sex,salary) {      Person.call(this,name,age,sex);       this.salary = salary;    }    // 创建学生的实例对象    var s1 = new Student("zs",18,"男",56);    var s2 = new Student("ls",19,"男",93);    console.dir(s1);    console.dir(s2);</code></pre><p><img src="https://img-blog.csdnimg.cn/4f43c35b162b4003bdae535f8e0eb923.png" alt="在这里插入图片描述"></p><p>优点：解决了不能向父类传参的问题。</p><p>缺点：父类的方法子类不可见，不能复用。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>将原型链和借用构造函数的组合到一块，兼具了二者的优点。</p><pre><code class="javascript">    // 组合继承：属性在构造函数内部继承，方法通过原型继承    function Person(name,age) {      this.name = name;      this.age = age;    }    Person.prototype.sayHi = function () {      console.log("你好");    }    // 生成一个子类型    function Teacher(name,age,salary) {      // 继承父类的属性      Person.call(this,name,age);      this.salary = salary;    }    // 方法继承，通过原型对象继承    Teacher.prototype = new Person();    Teacher.prototype.constructor = Teacher;    // 生成老师的一个实例    var t1 = new Teacher("ww",28,10000);    console.dir(t1);    console.log(t1.name);    t1.sayHi();</code></pre><p><img src="https://img-blog.csdnimg.cn/a7267c64b35046358304c680e5f639d3.png" alt="在这里插入图片描述"></p><p>优点：解决了原型链继承和借用构造函数继承的影响。</p><p>缺点：无论在什么情况下都会在创建子类原型和子类构造函数内部调用两次父类构造函数</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承：寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p><pre><code class="javascript">    function object(o){          function F(){}            F.prototype = o            return new F()        }    function createAnother(o){      var clone = object(o)      clone.sayHi = function(){        console.log("hello")    }    return clone    }    var person = {    name: "zs",    friends: ["ls", "ww", "xm"]    };    var p = createAnother(person);    p.sayHi()</code></pre><p>优点：写法简单，不需要单独创建构造函数。</p><p>缺点：通过寄生式继承给对象添加函数会导致函数难以重用。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>寄生组合式继承：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><pre><code class="javascript">  function object(o){        function F(){}          F.prototype = o          return new F()      }  function inheritPrototype(subType, superType){     var prototype = object(superType.prototype)    prototype.constructor = subType    subType.prototype = prototype  }  function SuperType(name){    this.name = name    this.colors = ["red", "blue", "green"]  }  SuperType.prototype.sayName = function(){    console.log(this.name)  };  function SubType(name, age){    SuperType.call(this, name)    this.age = age  }  inheritPrototype(SubType, SuperType)  SubType.prototype.sayAge = function(){    console.log(this.age)  }</code></pre><p>优点：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变；</p><p>缺点是：代码复杂</p><h2 id="ES6-Class"><a href="#ES6-Class" class="headerlink" title="ES6 Class"></a>ES6 Class</h2><p>本质上，ES6继承是一种语法糖。而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><pre><code class="javascript">    class Person {      constructor (name, age) {        this.name = name;        this.age = age;      }      sayHi () {        console.log("hello")      }       }    class Student extends Person {      constructor (name,age,number) {        super(name,age)        this.number = number      }      hello () {        super.sayHi()      }    }    const s1 = new Student("zs",18,101)    console.log(s1.name);    console.log(s1.age);    console.log(s1.number);    s1.hello();</code></pre><p><img src="https://img-blog.csdnimg.cn/db5774b9a80e4965b1dade36ab90f498.png" alt="在这里插入图片描述"><br>优点：语法简单易懂操作方便。</p><p>缺点：兼容问题，并不是所有浏览器都支持class关键字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2022/09/28/Internet/"/>
      <url>/2022/09/28/Internet/</url>
      
        <content type="html"><![CDATA[<h1 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h1><h2 id="How-does-Internet-work"><a href="#How-does-Internet-work" class="headerlink" title="How does Internet work?"></a>How does Internet work?</h2><p>​    互联网是网络的支柱，以这种技术为基础使网络成为可能。作为基础，互联网是把电脑互相连接起来的一个巨大的网络。</p><h2 id="What-is-HTTP"><a href="#What-is-HTTP" class="headerlink" title="What is HTTP?"></a>What is HTTP?</h2><p>​    超文本传输协议（HTTP）是万维网的基础，用于通过超文本连接加载网页。HTTP是应用程序层协议，旨在在互联网设备之间传输信息，并在网络协议栈的其它层之上运行。HTTP上的经典流涉及客户端计算机向服务器发出请求，然后服务器发送响应消息。</p><h4 id="什么是HTTP请求？"><a href="#什么是HTTP请求？" class="headerlink" title="什么是HTTP请求？"></a>什么是HTTP请求？</h4><p>​    HTTP请求是Internet通信平台（例如Web浏览器）索取其加载网站所需要信息的方式。</p><p>在Internet上发出的每个HTTP请求都携带一系列编码数据，这些数据带有不同类型的信息。典型的HTTP请求包含：</p><ol><li><p>HTTP版本类型</p></li><li><p>URL</p></li><li><p>HTTP方法</p></li><li><p>HTTP请求头</p></li><li><p>可选的HTTP正文</p></li></ol><h4 id="什么是HTTP请求头？"><a href="#什么是HTTP请求头？" class="headerlink" title="什么是HTTP请求头？"></a>什么是HTTP请求头？</h4><p>HTTP表头包含存储在键值对中的文本信息，并且它们包含在每个HTTP请求中（以及响应中）。这些标头可传达核心信息，如客户端正在使用什么浏览器以及正在请求什么数据。</p><p>chrome网络标签页的HTTP请求表头示例：</p><p><img src="https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-request-headers.png" alt="HTTP 请求标头"></p><h4 id="什么是HTTP请求正文？"><a href="#什么是HTTP请求正文？" class="headerlink" title="什么是HTTP请求正文？"></a>什么是HTTP请求正文？</h4><p>​    请求正文办函请求所传输信息的“主体”部分。HTTP请求的正文包含正在提交到Web服务器的任何信息，例如用户名和密码，或者输入到表单中的任何其他数据。</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是3位数代码，最常用于指示HTTP请求是否已经成功完成。状态码分为以下五个分区快：</p><p><a href="https://postimg.cc/nsSJkbxz"><img src="https://i.postimg.cc/mDBgTB6Q/1664410609538-1664410609594.png" alt="1664410609538-1664410609594.png"></a></p><p>1XX：代表请求已被接受，需要继续处理。</p><ul><li>100：客户端应当继续发送请求，服务器必须在请求完成后向客户端发送一个最终响应。</li></ul><ul><li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级。</li></ul><p>2XX:</p><ul><li>200（成功）:请求已经成功，请求希望的响应头或数据体将随此相应返回。</li></ul><ul><li>201（已创建）：请求成功并且有一个新的资源已经依据请求的需求而建立。</li></ul><ul><li>202（已接收）：服务器已接收请求，但尚未处理。</li></ul><ul><li>203（非授权信息）：服务器已成功接收请求，但返回的信息可能来自另一来源。</li></ul><ul><li>204（无内容）：服务器处理了请求，但不需要返回任何实体内容。</li></ul><ul><li>205（重置内容）：服务器处理了请求，且没有返回任何内容。与204不同的是此状态码响应要求请求者重置文档视图。主要用于接受用户输入后立即重置表单。</li></ul><ul><li>206（部分内容）：服务器处理了部分内容。</li></ul><p>3XX：</p><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者或浏览器选择一个首选的地址进行重定向。</li><li>301（永久移动）：被请求的资源已永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置。</li><li>302（临时移动）：请求的资源临时从不同的URL响应请求。客户端应当继续向原有的地址发送请求。</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的GET请求来检索响应服务器返回此代码。</li><li>304（未修改）：上次请求后，请求的资源未修改。服务器返回此响应时不返回网页内容。</li><li>305（使用代理）：请求者只能通过代理访问请求的网页。如果服务器返回此响应，表示请求者应当使用代理。</li><li>307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置进行以后的请求，临时重定向，和302类似，但是期望客户端保持请求方法不向新的地址发出请求。</li></ul><p>4XX：</p><ul><li>400（错误请求）：请求无法被服务器理解。</li><li>401（未授权）：请求要求身份验证。对于需要登陆的网页服务器可能会返回此响应。</li><li>403（禁止）：服务器已经理解请求，但是拒绝执行它。</li><li>404（未找到）：服务器找不到请求的网页。</li><li>405（方法禁用）：禁用请求中制定的方法，请求中指定的请求方法不能用于请求相应的资源。</li><li>406（不接受）：无法使用请求的内容特性响应请求的网页。</li><li>407（需要代理授权）：与401类似，但指定请求者应当授权使用代理。</li><li>408（请求超时）：服务器等候请求时发生超时。</li></ul><p>5XX：</p><ul><li>500（服务器内部错误）：服务器内部遇到错误，无法完成请求。</li><li>501（尚未实施）：服务器不支持当前请求所需要的某个功能。</li><li>502（错误网关）：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503（服务不可用）：服务器目前无法使用（处于超载或停机维护）</li><li>504（网关超时）：作为网关或代理工作的服务器尝试执行请求时，未能及时从上游服务器收到请求。</li><li>505（HTTP版本不受支持）：服务器不支持请求中所使用的HTTP协议版本。</li></ul><h4 id="什么是HTTP响应标头？"><a href="#什么是HTTP响应标头？" class="headerlink" title="什么是HTTP响应标头？"></a>什么是HTTP响应标头？</h4><p>​    与HTTP请求非常相似，HTTP响应也带有标头，用于长达重要的信息，例如在响应正文中发送的数据的语言和格式。</p><p>HTTP响应标头实例：<img src="https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-response-headers.png" alt="HTTP 响应标头"></p><h4 id="什么是HTTP响应正文？"><a href="#什么是HTTP响应正文？" class="headerlink" title="什么是HTTP响应正文？"></a>什么是HTTP响应正文？</h4><p>​    成功回应“GET”请求时，HTTP响应通常具有包含所请求信息的正文。在大多数Web请求中，这是HTML数据，Web浏览器会将其转换为网页。</p><h2 id="Browsers-and-how-they-work"><a href="#Browsers-and-how-they-work" class="headerlink" title="Browsers and how they work?"></a>Browsers and how they work?</h2><h2 id="DNS-and-how-it-works"><a href="#DNS-and-how-it-works" class="headerlink" title="DNS and how it works?"></a>DNS and how it works?</h2><h4 id="DNS如何工作？"><a href="#DNS如何工作？" class="headerlink" title="DNS如何工作？"></a>DNS如何工作？</h4><p>​    DNS解析过程涉及将主机名（例如：<a href="http://www.aucanon.top/">www.aucanon.top</a> ）转换为计算机友好的IP地址（例如：185.199.109.153。</p><h4 id="DNS同时使用TCP和UDP协议"><a href="#DNS同时使用TCP和UDP协议" class="headerlink" title="DNS同时使用TCP和UDP协议"></a>DNS同时使用TCP和UDP协议</h4><p>​    DNS占用53号端口，同时使用TCP和UDP协议。</p><p>在区域传输的时候使用TCP协议，在域名解析的时候使用UDP协议。</p><h4 id="DNS的查询方式"><a href="#DNS的查询方式" class="headerlink" title="DNS的查询方式"></a>DNS的查询方式</h4><ol><li>递归查询：指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询用户只需要发出一次查询请求。</li><li>迭代查询：查询请求后域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。</li><li>非递归查询：当DNS解析器用户端查询DNS服务器以获取其有权访问的记录时通常会进行此查询，因为对其该记录具有权威性，或者该记录存在其缓存内。DNS服务器通常会缓存DNS记录，以防止更多带宽消耗和上游服务器的负载。</li></ol><h4 id="DNS查询步骤"><a href="#DNS查询步骤" class="headerlink" title="DNS查询步骤"></a>DNS查询步骤</h4><ol><li>首先搜索浏览器的DNS缓存，缓存中维护一张域名与IP地址对应的表。</li><li>若没有命中则继续搜索操作系统的DNS缓存。</li><li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的DNS缓存，查找成功则直接返回结果。</li><li>若本地域名服务器的DNS缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。</li><li>首先本地域名服务器向根域名服务器发起请求 ，根域名服务器返回顶级域名服务器的地址给本地服务器，本地服务器拿到顶级域名服务器的地址后就像其发起请求忙活去权限域名服务器的地址。本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的IP地址。</li><li>本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来。</li><li>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来。</li><li>至此浏览器就得到了域名对应的IP地址并将IP地址缓存起来。</li></ol><h2 id="What-is-Domain-Name"><a href="#What-is-Domain-Name" class="headerlink" title="What is Domain Name?"></a>What is Domain Name?</h2><h4 id="什么是域名？"><a href="#什么是域名？" class="headerlink" title="什么是域名？"></a>什么是域名？</h4><p>​    域名是一个文本字符串，映射到一个数字IP地址，可以从客户端软件访问网站。简单的说域名就是用户在浏览器窗口中键入以访问特定网站的文本。</p><h4 id="域名和URL有什么区别？"><a href="#域名和URL有什么区别？" class="headerlink" title="域名和URL有什么区别？"></a>域名和URL有什么区别？</h4><p>​    统一资源定位符（URL）有时也称为网址，包含站点的域名以及其他信息，如传输协议和路径等。</p><h4 id="域名有哪些部分组成？"><a href="#域名有哪些部分组成？" class="headerlink" title="域名有哪些部分组成？"></a>域名有哪些部分组成？</h4><p>​    域名通常分成两个或三个部分，各部分用一个点分割。从左到右阅读时，域名中的标识符从最广泛到具体。域名最后一个点右边的部分是顶级域名（TLD）。其中包括“.com”、“.bet”和“.org”等“通用”TLD，以及以“.uk”、“.jp”等特定国家或地区的TLD。</p><p>​    TLD左侧是第二级域名（2LD），如果2LD的左侧有任何内容，则称为第三极域（3LD）。</p><h2 id="What-is-hosting？"><a href="#What-is-hosting？" class="headerlink" title="What is hosting？"></a>What is hosting？</h2><p>​    网页寄存（Web hosting）是指一类因特网的寄存服务，他提供个人，组织和用户用于存储信息、图像、视频或任何可访问的内容的在线系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Router</title>
      <link href="/2022/07/24/Vue%20Router/"/>
      <url>/2022/07/24/Vue%20Router/</url>
      
        <content type="html"><![CDATA[<h3 id="前后端路由"><a href="#前后端路由" class="headerlink" title="前后端路由"></a>前后端路由</h3><p>路由就是一个key-value的映射关系。（路径-component/function）</p><h5 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h5><p>前端路由的value即component，不同的路径展示不同的组件。<br>vue-router专门用来实现SPA应用。</p><blockquote><p><code>SPA</code>应用：单页面WEB应用，导航连接的改变不会刷新整个页面，指挥更新局部的页面。并且数据需要通过ajax请求获得。</p></blockquote><h5 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h5><p>value对应function，根据根据请求路径匹配相应的函数处理响应请求。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>路由组件</p><blockquote><p>路由组件通常放在项目目录pages或者views中，并且通过路由使用相应的组件。</p></blockquote><p>非路由组件</p><blockquote><p>非路由组件通常放在项目目录components中，并且通过对应标签使用</p></blockquote><p>vue-router使用:</p><ol><li>下载vue-router： <code>npm i vue-router</code></li><li>引入vue-router：<code>import VueRouter from 'vue-router'</code></li><li>使用vue-router插件： <code>Vue.use(VueRouter)</code></li><li>在入口文件main.js中进行全局注册：</li></ol><pre><code class="javascript">//引入Vueimport Vue from 'vue'//引入Appimport App from './App.vue'//引入VueRouterimport VueRouter from 'vue-router'//引入路由器import router from './router'//应用插件Vue.use(VueRouter)//创建vmnew Vue({    el: '#app',    render: h =&gt; h(App),    router: router})</code></pre><ol start="5"><li>编写router配置项</li></ol><pre><code class="javascript">//引入VueRouterimport VueRouter from 'vue-router'//引入Luyou 组件import About from '../components/About'import Home from '../components/Home'//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter({    routes:[        {            path:'/about',            component:About        },        {            path:'/home',            component:Home        }    ]})//暴露routerexport default router</code></pre><blockquote><p>通过切换隐藏的路由组件默认是呗销毁的，当需要用的时候再去挂载上。</p></blockquote><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>多级路由要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置。</p><pre><code class="javascript">routes:[    {        path:'/about',        component:About,    },    {        path:'/home',        component:Home,        children:[ //通过children配置子级路由            {                path:'child1',                component:Child1            },            {                path:'child2',                component:Child2            }        ]    }]</code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h4><p>不属于路径中的一部分，路径与参数之间用<code>？</code>隔开,路由信息配置path时不需要占位</p><p>声明式导航传参：</p><p>传递参数：</p><pre><code class="javascript">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to="/home/message/detail?id=666&amp;title=你好"&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link     :to="{        path:'/home/message/detail',        query:{           id:666,            title:'你好'        }    }"&gt;跳转&lt;/router-link&gt;</code></pre><p>接收参数：</p><p><code>$route.query.id</code><br><code>$route.query.title</code></p><blockquote><p>to的对象写法中的path可以换成name。</p></blockquote><p>编程式导航传参：</p><p>传递参数：</p><pre><code class="javascript">this.$route.push({    name:'search',    query:{        k:123    }</code></pre><p>接收参数与声明式导航相同。</p><blockquote><p>编程式导航的配置项不能使用path,只能使用name</p></blockquote><h4 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h4><p>属于路径中的一部分，需要注意，在配置路由时，路由信息配置path时需要占位<br>路由配置时声明接收params参数：</p><pre><code class="javascript">{    path:'/home',    component:Home,    children:[        {            path:'news',            component:News,        },        {            path:'message',            component:Message,            children:[                {                    name:'xiangqing',                    path:'detail/:id/:title',                    component:Detail,                }            ]        }    ]}</code></pre><p>参数的传递和接收与query参数传递相似</p><blockquote><p>路由携带params参数时，如使用to的对象写法，则不能使用path配置项，必须使用name</p></blockquote><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>能够简化路由的跳转</p><ol><li>给路由命名，增加name属性</li></ol><pre><code class="javascript">{    path:'/demo',    component:Demo,    children:[        {            path:'test',            component:Test,            children:[                {                      name:'hello' //给路由命名                    path:'welcome',                    component:Hello,                }            ]        }    ]}</code></pre><ol start="2"><li>   简化跳转：</li></ol><pre><code class="javascript">&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to="/demo/test/welcome"&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to="{name:'hello'}"&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link     :to="{        name:'hello',        query:{           id:666,            title:'你好'        }    }"    &gt;跳转&lt;/router-link&gt;</code></pre><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><h4 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h4><pre><code class="javascript">//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;{    console.log('beforeEach',to,from)    if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制        if(localStorage.getItem('house') === 'washroom'){ //权限控制的具体规则            next() //放行        }else{            alert('暂无权限进入')        }    }else{        next() //放行    }})//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;{    console.log('afterEach',to,from)    if(to.meta.title){         document.title = to.meta.title //修改网页的title    }else{        document.title = 'my_house'    }})</code></pre><blockquote><p>后置路由守卫没有 next</p></blockquote><h4 id="独享守卫"><a href="#独享守卫" class="headerlink" title="独享守卫"></a>独享守卫</h4><p>配置独享守卫的路由组件就需要权限进入</p><pre><code class="javascript">beforeEnter(to,from,next){    console.log('beforeEnter',to,from)    if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制        if(localStorage.getItem('house') === 'washroom'){            next()        }else{            alert('暂无权限进入')        }    }else{        next()    }}</code></pre><h4 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h4><p>组件内路由守卫是在组件内编写</p><pre><code class="javascript">//通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) {    if(to.meta.isAuth){ //判断是否需要鉴权        if(localStorage.getItem('house')==='washroom'){            next()        }else{            alert('错误！无权限进入！')        }    }else{        next()    }},//通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) {    next()}</code></pre><blockquote><p><code>next()</code> 表示直接放行,<br><code>next('/home')</code> 表示直接放行到home路由<br><code>next(false)</code> 表示停留在原来的路由</p></blockquote><h3 id="路由独有的两个生命周期钩子"><a href="#路由独有的两个生命周期钩子" class="headerlink" title="路由独有的两个生命周期钩子"></a>路由独有的两个生命周期钩子</h3><p>能够对路由组件的激活状态进行捕捉</p><blockquote><p><code>activated</code>：路由组件被激活时触发<br><code>deactivated</code>：路由组件失活时触发</p></blockquote><h3 id="路由的两种工作模式"><a href="#路由的两种工作模式" class="headerlink" title="路由的两种工作模式"></a>路由的两种工作模式</h3><pre><code>1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。3. hash模式：     1. 地址中永远带着#号，不美观 。        2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。       3. 兼容性较好。4. history模式：       1. 地址干净，美观 。      2. 兼容性和hash模式相比略差。       3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex组件间通信</title>
      <link href="/2022/07/23/Vuex%E7%BB%84%E5%BB%BA%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/07/23/Vuex%E7%BB%84%E5%BB%BA%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><ul><li><p>状态，驱动应用的数据源；</p></li><li><p>视图，以声明方式将状态映射到视图；</p></li><li><p>操作，响应在视图上的用户输入导致的状态变化。<br><img src="https://img-blog.csdnimg.cn/892e8370113c4e11b4de93f920052335.png" alt="请添加图片描述"><br>但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p></li><li><p>多个视图依赖于同一状态。</p></li><li><p>来自不同视图的行为需要变更同一状态。<br><img src="https://img-blog.csdnimg.cn/c056f7b2ba5b4c09ab2507c70081a838.png" alt="请添加图片描述"></p></li></ul><p>Vuex可以适用于多个组件之间共享数据</p><h4 id="安装Vuex"><a href="#安装Vuex" class="headerlink" title="安装Vuex"></a>安装Vuex</h4><blockquote><p><code>npm install vuex@next --save</code></p></blockquote><h4 id="搭建Vuex环境："><a href="#搭建Vuex环境：" class="headerlink" title="搭建Vuex环境："></a>搭建Vuex环境：</h4><p>创建文件<code>src/store/inde.js</code></p><pre><code class="javascript">//引入Vue核心库import Vue from 'vue'//引入Vueximport Vuex from 'vuex'//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = {}//准备mutations对象——修改state中的数据const mutations = {}//准备state对象——保存具体的数据const state = {}//创建并暴露storeexport default new Vuex.Store({    actions,    mutations,    state})</code></pre><p>在入口文件<code>mian.js</code>添加配置项：</p><pre><code class="javascript">......//引入storeimport store from './store'......//创建vmnew Vue({    el:'#app',    render: h =&gt; h(App),    store})</code></pre><blockquote><p><code>state</code>:初始化存储数据</p></blockquote><blockquote><p><code>getters</code>:Vuex 允许我们在 store 中定义“getters”（可以认为是 store 的计算属性）。</p></blockquote><blockquote><p><code>mutation</code>:唯一更改state数据状态的方法就是提交mutation，并且它会接受 state 作为第一个参数。</p></blockquote><blockquote><p><code>action </code>:action 提交的是 mutation，而不是直接变更状态,并且action 可以进行异步操作。</p></blockquote><p>组件中进行读取数据：<code>$store.state.data</code></p><p>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',data)</code></p><h4 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h4><blockquote><p><code>mapState</code>：将state中的数据映射为计算属性。</p></blockquote><pre><code class="javascript">computed: {    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState({sum:'sum',school:'school'}),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState(['sum','school']),},</code></pre><blockquote><p><code>mapGetters</code>：将getters中的数据映射为计算属性。</p></blockquote><pre><code class="javascript">computed: {    //借助mapGetters生成计算属性：getSum（对象写法）    ...mapGetters({getSum:'getSum'}),    //借助mapGetters生成计算属性：getSum（数组写法）    ...mapGetters(['getSum'])},</code></pre><blockquote><p><code>mapAction</code>：将action中的数据映射为计算属性。</p></blockquote><pre><code class="javascript">methods:{    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions(['jiaOdd','jiaWait'])}</code></pre><blockquote><p><code>mapMutation</code>：将mutation中的数据映射为计算属性。</p></blockquote><pre><code class="javascript">methods:{    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations({increment:'JIA',decrement:'JIAN'}),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations(['JIA','JIAN']),}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue插槽</title>
      <link href="/2022/07/23/Vue%E6%8F%92%E6%A7%BD/"/>
      <url>/2022/07/23/Vue%E6%8F%92%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>用于父子组件之间的通信（一般是结构，即标签）</p><p>可放置在函数参数位置的 JavaScript 表达式 (在支持的环境下可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</p><blockquote><p>父组件向子组件指定位置插入html结构（默认插槽、具名插槽），或者子组件给父组件传递数据，父组件决定插入子组件对应位置的结构（作用域插槽）</p></blockquote><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'',    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="javascript">&lt;template&gt;    &lt;div class="container"&gt;        &lt;GetUser&gt;            &lt;ul&gt;                &lt;li v-for="(people,index) in name" :key="index"&gt;{{people}}&lt;/li&gt;            &lt;/ul&gt;        &lt;/GetUser&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import GetUser from './components/GetUser'    export default {        name:'App',        components:{GetUser},        data() {            return {                name:['zs','ls','ww','ml'],            }        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;slot name="first"&gt;&lt;/slot&gt;        &lt;slot name="cecond"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'GetUser',    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;GetUser&gt;            &lt;ul slot="first"&gt;                &lt;li v-for="(people,index) in name" :key="index"&gt;{{people}}&lt;/li&gt;            &lt;/ul&gt;            &lt;div slot="cecond"&gt;                &lt;a href="#"&gt;小明&lt;/a&gt;            &lt;/div&gt;        &lt;/GetUser&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import GetUser from './components/GetUser'    export default {        name:'App',        components:{GetUser},        data() {            return {                name:['张三','李四','王五','马六'],            }        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>数据在子组件中，但是自己不能决定结构，需要将数据传递给父组件，父组件决定结构。</p><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;slot :people="people"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'GetUser',        data() {            return {                people:['张三','李四','王五','马六'],            }        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;GetUser&gt;            &lt;template scope="man"&gt;                &lt;ul&gt;                    &lt;li v-for="(user,index) in man.people" :key="index"&gt;{{user}}&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/GetUser&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import GetUser from './components/GetUser'    export default {        name:'App',        components:{GetUser},    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件间通信</title>
      <link href="/2022/07/23/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/07/23/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p> 组件间通信</p><h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>用于父组件给子组件传值</p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote><p><code>props</code>接收时有三种形式：</p><ol><li>默认接收：<code>prop:['name']</code></li><li>限制类型接收：<code>props:{name:String}</code></li><li>限制类型、必要性、指定默认值：</li></ol><pre><code class="javascript">props:{    name:{        type:String,        required:true,        default:'zhangsan'    }}</code></pre><p>父组件在子组件身上传递数据：</p><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;Student name="zhangsan" sex="男" :age="18"/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import Student from './components/Student'    export default {        name:'App',        components:{Student}    }&lt;/script&gt;</code></pre><p>子组件通过<code>props</code>属性接收父组件传递的数据：</p><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;        &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'Student',        props:{            name:{                type:String, //name的类型是字符串                required:true, //name是必要的            },            age:{                type:Number,                default:18 //默认值            },            sex:{                type:String,                required:true            }        }    }&lt;/script&gt;</code></pre><blockquote><p>注意：data中的数据是可读可写的；props中的属性只是可读的，无法重新赋值，重新赋值会报错（也就是说，子组件不要直接去修改父组件中的数据）。</p></blockquote><h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>用于子组件给父组件传递数据</p><p>子组件中触发自定义事件（触发<code>emit</code>事件）</p><blockquote><p>比如在子组件中有一个点击事件：点击事件中的方法中this.$emit(‘自定义事件名称’，传递的参数)</p></blockquote><pre><code class="javascript">&lt;template&gt;    &lt;div class="student"&gt;        &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;性别：{{sex}}&lt;/h2&gt;        &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;        &lt;button @click="sendStudentlName"&gt;把姓名传递给App&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'Student',        data() {            return {                name:'张三',                sex:'男',                age:18            }        },        methods: {            sendStudentlName(){                //触发Student组件实例身上的transmit事件                this.$emit('transmit',this.name,666,888,900)            },        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>父组件定义自定义事件并接收数据</p><blockquote><p>在父组件中的子标签上写自定义事件及方法@自定义事件名称=”方法名称”</p></blockquote><pre><code class="javascript">&lt;template&gt;    &lt;div class="app"&gt;        &lt;h1&gt;学生姓名是:{{studentName}}&lt;/h1&gt;        &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（使用@或v-on使用ref） --&gt;        &lt;Student ref="student" @click.native="show"/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import Student from './components/Student'    export default {        name:'App',        components:{Student},        data() {            return {                studentName:''            }        },        methods: {            getStudentName(name){                this.studentName = name            },            show(){                alert('tt')            }        },        mounted() {            this.$refs.student.$on('transmit',this.getStudentName) //绑定自定义事件        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h1 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h1><p>一种适用于任意组件间的通信方式<br>安装全局事件总线：</p><blockquote><p>在入口文件<code>main.js</code>中在使用<code>beforecreate</code>实例初始化之后安装</p></blockquote><pre><code class="javascript">import Vue from 'vue'import App from './App.vue'new Vue({    el:'#app',    render: h =&gt; h(App),    beforeCreate() {        Vue.prototype.$bus = this //安装全局事件总线    },})</code></pre><blockquote><p><code>$bus</code>就是当前应用的vm实例</p></blockquote><p>使用事件总线：</p><blockquote><p>传递数据：<code>this.$bus.$emit('***',data)</code></p></blockquote><blockquote><p>接收数据：<code>this.$bus.$on('***',this.方法名)</code>/<code>this.$bus.$on('***',回调函数)</code><br>（回调函数写成箭头函数形式）</p></blockquote><blockquote><p>最后最好在beforeDestroy钩子中使用<code>$off</code>对当前组件所使用到的事件进行解绑</p></blockquote><pre><code class="javascript">&lt;template&gt;    &lt;div class="student"&gt;        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;        &lt;button @click="sendStudentName"&gt;把学生名传递给School组件&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'Student',        data() {            return {                name:'张三',                sex:'男',            }        },        methods: {            sendStudentName(){                this.$bus.$emit('hello',this.name)            }        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="javascript">&lt;template&gt;    &lt;div class="school"&gt;        &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'School',        data() {            return {                name:'李四',                address:'北京',            }        },        mounted() {            this.$bus.$on('hello',(data)=&gt;{                console.log(data)            })        },        beforeDestroy() {            this.$bus.$off('hello')        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><blockquote><p><code>$on</code>:绑定事件；<code>$emit</code>:触发事件；<code>$off</code>:解绑事件</p></blockquote><h1 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h1><p>通过pubsub.js插件，可用于任意组件间通信<br>1.安装插件：<code>npm i pubsub-js</code><br>2.引入：<code>import pubsub from 'pubsub-js'</code><br>3.数据发送：<code>pubsub.publish('xxx',数据)</code><br>4.数据接收：<code>pubsub.subscribe('xxx',data)</code></p><p>数据发送：</p><pre><code class="javascript">&lt;template&gt;    &lt;div class="student"&gt;        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;        &lt;button @click="sendStudentName"&gt;把学生名传递给School组件&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import pubsub from 'pubsub-js'    export default {        name:'Student',        data() {            return {                name:'张三',                sex:'男',            }        },        methods: {            sendStudentName(){                pubsub.publish('hello',this.name)            }        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>数据接收：</p><pre><code class="javascript">&lt;template&gt;    &lt;div class="school"&gt;        &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import pubsub from 'pubsub-js'    export default {        name:'School',        data() {            return {                name:'李四',                address:'北京',            }        },        mounted() {            this.pubId = pubsub.subscribe('hello',(msgName,data)=&gt;{                console.log(data)            })        },        beforeDestroy() {            pubsub.unsubscribe(this.pubId)        },    }&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><blockquote><p>最后也最好在beforeDestroy钩子中使用 <code>PubSub.unsubscribe(pid)</code>取消订阅</p></blockquote><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p><a href="https://blog.csdn.net/weixin_51524737/article/details/125950480">Vuex组件间通信</a></p><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p><a href="http://t.csdn.cn/jUa0r">slot插槽</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--mixin混入</title>
      <link href="/2022/06/02/Vue%E6%A0%B8%E5%BF%83--mixin%E6%B7%B7%E5%85%A5/"/>
      <url>/2022/06/02/Vue%E6%A0%B8%E5%BF%83--mixin%E6%B7%B7%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>﻿&gt;混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><blockquote><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<br>不推荐在应用代码中使用。</p></blockquote><p>首先要定义一个混合，通常在src内创建一个mixin.js文件在该文件内定义所需要的混入。</p><pre><code class="javascript">export const mix = {    methods: {        showName(){            alert(this.name)        }    },    mounted() {        console.log('hello')    },}export const mixe = {    data() {        return {            a:1,            b:2        }    },}</code></pre><p>全局混入：混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p><pre><code class="javascript">import Vue from 'vue'import App from './App.vue'import {mix,mixe} from './mixin'Vue.config.productionTip = falseVue.mixin(mix)Vue.mixin(mixe)new Vue({    el:'#app',    render: h =&gt; h(App)})</code></pre><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;        &lt;button @click="showName"&gt;点击&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:'Student',        data() {            return {                name:'张三',                sex:'女'            }        },    }&lt;/script&gt;</code></pre><blockquote><p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。</p></blockquote><p>局部混入：</p><pre><code class="javascript">&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;        &lt;button @click="showName"&gt;点击&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import { mix } from './mixin'    export default {        name:'Student',        data() {            return {                name:'张三',                sex:'女'            }        },        mixins:[mix]    }&lt;/script&gt;</code></pre><blockquote><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。<br>比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--filter过滤器</title>
      <link href="/2022/06/01/Vue%E6%A0%B8%E5%BF%83--filter%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/06/01/Vue%E6%A0%B8%E5%BF%83--filter%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 <code>v-bind</code> 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号<code>|</code>指示</p><blockquote><p>功能：对要显示的数据进行特定格式化后再显示。</p></blockquote><blockquote><p>过滤器也可以接收额外参数、多个过滤器也可以串联。</p></blockquote><blockquote><p>注意：并没有改变原本的数据, 是产生新的对应的数据。</p></blockquote><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="UTF-8" /&gt;        &lt;title&gt;过滤器&lt;/title&gt;        &lt;script type="text/javascript" src="./vue.js"&gt;&lt;/script&gt;        &lt;script type="text/javascript" src="./dayjs.min.js"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="root"&gt;            &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;            &lt;!-- 过滤器实现 --&gt;            &lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt;            &lt;!-- 过滤器实现（传参） --&gt;            &lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt;            &lt;h3 :x="msg | mySlice"&gt;hello_vue&lt;/h3&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script&gt;        Vue.config.productionTip = false                new Vue({            el:'#root',            data:{                time:1621562557846, //时间戳                msg:'learn_vue'            },            filters:{                timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){                    return dayjs(value).format(str)                }            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre><p>全局过滤器</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="UTF-8" /&gt;        &lt;title&gt;过滤器&lt;/title&gt;        &lt;script type="text/javascript" src="./vue.js"&gt;&lt;/script&gt;        &lt;script type="text/javascript" src="./dayjs.min.js"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="root"&gt;            &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script&gt;        Vue.config.productionTip = false        Vue.filter('mySlice',function(value){            return value.slice(0,4)        })        new Vue({            el:'#root',            data:{                msg:'good_vue!'            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--生命周期</title>
      <link href="/2022/06/01/Vue%E6%A0%B8%E5%BF%83--%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/06/01/Vue%E6%A0%B8%E5%BF%83--%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>﻿&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><blockquote><p>所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 <code>created: () =&gt; this.fetchTodos()</code>)。因为箭头函数绑定了父级上下文，所以 <code>this</code> 不会指向预期的组件实例，并且<code>this.fetchTodos</code> 将会是 undefined。</p></blockquote><p>最开始我们应该是要通过new创建一个Vue的实例化对象。<br><img src="https://img-blog.csdnimg.cn/25b04662b91747ad8231c5a2181f62b9.png#pic_center" alt="在这里插入图片描述"><br>生命周期钩子：<br>分为四个阶段四对钩子<br>|阶段| 钩子 |  |<br>|–|–|–|<br>| 初始化 | beforeCreate| created|<br>| 挂载 |beforeMount| mounted |<br>| 更新 | beforeUpdate | updated |<br>| 销毁 | beforeDestroy | destroyed |</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><p><code>beforeCreate</code>：在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。<br> ——在此时没有Vue实例，访问不到data中的数据和methods内的方法。</p></blockquote><p>执行完后开始进行数据的初始化，这个过程会定义data数据、方法及事件，并完成数据劫持observe以及给组件实例配置watcher观察者实例。</p><blockquote><p><code>created</code>：在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。<br>——完成了实例的创建，已经能够访问到data中的数据和methods中的方法了。</p></blockquote><p>确保有了<code>el</code>之后会判断有没有<code>rander</code>函数，如果没有就回去找<code>template</code>将其转换为<code>rander</code>函数。</p><blockquote><p><code>beforeMount</code>:在挂载开始之前被调用：相关的 render 函数首次被调用。<br>该钩子在服务器端渲染期间不被调用。<br>——此时DOM结构未经过Vue编译，没有将编译的HTML渲染到页面。</p></blockquote><p>渲染<code>rander</code>函数，产生一个虚拟DOM并进行新老DOM之间的对比计算后进行保存，然后直接将rander渲染为真实DOM。</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><blockquote><p><code>mounted</code>:实例被挂载后调用，这时 el 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<br>该钩子在服务器端渲染期间不被调用。<br>——可在此进行：开启定时器、订阅消息、发送网络请求、绑定自定义事件等。</p></blockquote><p>在<code>mounted</code>函数内可以进行DOM操作，因为在此DOM已经渲染完成了。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><blockquote><p><code>beforeUpdate</code>:在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。<br>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。<br>——此时数据是新的，但页面是旧的。</p></blockquote><p><code>beforeUpdate</code>调用之后会生成新的虚拟DOM然后再拿回去和旧的进行diff算法的对比计算。更新<code>rander</code>函数并将新的<code>rander</code>函数渲染成真实DOM。</p><blockquote><p><code>updated</code>:在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br>注意，<code>updated</code> 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 <code>updated</code> 里使用 <code>vm.$nextTick</code><br>——此时数据和页面都是新的。</p></blockquote><p>在update中也可以操作DOM而且是已经更新后的DOM。</p><blockquote><p><code>before</code>:实例销毁之前调用。在这一步，实例仍然完全可用。<br>该钩子在服务器端渲染期间不被调用。<br>——可在此进行关闭定时器、取消订阅消息、解绑自定义事件等。</p></blockquote><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>beforeDestroy之后会进行一系列的销毁动作。解除各种数据引用、移除事件监听、删除组件watcher、删除子实例、删除自身self等。并将实例属性<code>_isDestroyed</code>设置为true。</p><blockquote><p><code>destroyed</code>：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。<br>该钩子在服务器端渲染期间不被调用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--计算属性、监事属性</title>
      <link href="/2022/06/01/Vue%E6%A0%B8%E5%BF%83--%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E7%9B%91%E4%BA%8B%E5%B1%9E%E6%80%A7/"/>
      <url>/2022/06/01/Vue%E6%A0%B8%E5%BF%83--%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E7%9B%91%E4%BA%8B%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h1><ul><li>定义：要用的属性不存在，要通过已有的属性计算得来(data)。</li><li>原理：底层借助<code>Object.defineProperty</code>方法提供的<code>getter</code>和<code>setter</code>。</li><li><code>get</code>函数初次读取时执行一次、当依赖的函数改变再次调用。</li><li>与<code>methods</code>相比，内部有缓存机制（复用）效率更高，调试方便。<blockquote><p>计算属性最终会出现在<code>vm</code>上，直接读取使用即可。</p></blockquote></li></ul><blockquote><p>如果计算属性要被修改，必须写<code>set</code>函数去响应修改，且<code>set</code>中要引起计算时依赖的数据发生改变。</p></blockquote><blockquote><p>计算属性依赖<code>data</code>中的数据时，<code>data</code>中它所依赖的数据变化时，他也跟着变化</p></blockquote><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="UTF-8" /&gt;        &lt;title&gt;计算属性实现&lt;/title&gt;        &lt;script type="text/javascript" src="./vue.js"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="root"&gt;            姓：&lt;input type="text" v-model="firstName"&gt; &lt;br/&gt;&lt;br/&gt;            名：&lt;input type="text" v-model="lastName"&gt; &lt;br/&gt;&lt;br/&gt;            全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type="text/javascript"&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。        const vm = new Vue({            el:'#root',            data:{                firstName:'张',                lastName:'三',            },            computed:{                fullName:{                    get(){                        console.log('get被调用了')                        return this.firstName + '-' + this.lastName                    },                    set(value){                        console.log('set',value)                        const arr = value.split('-')                        this.firstName = arr[0]                        this.lastName = arr[1]                    }                }            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre><p>上面是完整的写法，还有简写的方式。当只有<code>get</code>时可以使用简写方式：</p><pre><code class="javascript">fullName(){            console.log('get被调用了')            return this.firstName + '-' + this.lastName}</code></pre><h1 id="监事属性watch"><a href="#监事属性watch" class="headerlink" title="监事属性watch"></a>监事属性watch</h1><p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 <code>watch</code> 对象的每一个 <code>property</code>。</p><ul><li><p>当被监视的属性变化时，回调函数自动调用，进行相关操作。</p></li><li><p>监视的属性必须存在，才能进行监视。</p></li><li><p>data中的属性可以被监视，计算属性<code>computed</code>中的属性也可以被监视。</p><blockquote><p>注意，不应该使用箭头函数来定义 <code>watcher</code> 函数 (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p></blockquote><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;      &lt;meta charset="UTF-8" /&gt;      &lt;title&gt;天气案例_监视属性&lt;/title&gt;      &lt;script type="text/javascript" src="./vue.js"&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;div id="root"&gt;          &lt;h2&gt;今天天气{{info}}&lt;/h2&gt;          &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;      &lt;/div&gt;  &lt;/body&gt;  &lt;script type="text/javascript"&gt;      Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。            const vm = new Vue({          el:'#root',          data:{              isHot:true,          },          computed:{              info(){                  return this.isHot ? '炎热' : '凉爽'              }          },          methods: {              changeWeather(){                  this.isHot = !this.isHot              }          },          /* watch:{              isHot:{                  immediate:true, //初始化时让handler调用一下                  //handler什么时候调用？当isHot发生改变时。                  handler(newValue,oldValue){                      console.log('isHot被修改了',newValue,oldValue)                  }              }          } */      })      vm.$watch('isHot',{          immediate:true, //初始化时让handler调用一下          //handler什么时候调用？当isHot发生改变时。          handler(newValue,oldValue){              console.log('isHot被修改了',newValue,oldValue)          }      })  &lt;/script&gt;&lt;/html&gt;</code></pre><p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调立即执行。</p></li></ul><p>深度监视：<br>为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="UTF-8" /&gt;        &lt;title&gt;深度监视&lt;/title&gt;        &lt;script type="text/javascript" src="./vue.js"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="root"&gt;            &lt;h2&gt;今天天气{{info}}&lt;/h2&gt;            &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;            &lt;hr/&gt;            &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt;            &lt;button @click="numbers.a++"&gt;点我让a+1&lt;/button&gt;            &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt;            &lt;button @click="numbers.b++"&gt;点我让b+1&lt;/button&gt;            &lt;button @click="numbers = {a:666,b:888}"&gt;彻底替换掉numbers&lt;/button&gt;            {{numbers.c.d.e}}        &lt;/div&gt;    &lt;/body&gt;    &lt;script type="text/javascript"&gt;        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。                const vm = new Vue({            el:'#root',            data:{                isHot:true,                numbers:{                    a:1,                    b:1,                    c:{                        d:{                            e:100                        }                    }                }            },            computed:{                info(){                    return this.isHot ? '炎热' : '凉爽'                }            },            methods: {                changeWeather(){                    this.isHot = !this.isHot                }            },            watch:{                isHot:{                    handler(newValue,oldValue){                        console.log('isHot被修改了',newValue,oldValue)                    }                },                numbers:{                    deep:true,                    handler(){                        console.log('numbers改变了')                    }                }            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre><p>也可以简写：</p><pre><code class="javascript">isHot(newValue,oldValue){    console.log('isHot被修改了',newValue,oldValue,this)}</code></pre><pre><code class="javascript">vm.$watch('isHot',(newValue,oldValue)=&gt;{    console.log('isHot被修改了',newValue,oldValue,this)})</code></pre><p>计算属性和监视属性的区别：</p><blockquote><p>computed能完成的功能，watch都可以完成<br>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--MVVM模型</title>
      <link href="/2022/05/30/Vue%E6%A0%B8%E5%BF%83--MVVM%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/05/30/Vue%E6%A0%B8%E5%BF%83--MVVM%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><p>MVVM 是Model-View-ViewModel 的缩写</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><blockquote><p>就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p></blockquote><h4 id="视图模型"><a href="#视图模型" class="headerlink" title="视图模型"></a>视图模型</h4><blockquote><p>视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</p></blockquote><h4 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h4><blockquote><p>声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。 绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/362ff34a7ec747c483163370345d9ef4.png#pic_center" alt="在这里插入图片描述"></p><ul><li>M：模型(Model) ：对应 data 中的数据</li><li>V：视图(View) ：模板</li><li>VM：视图模型(ViewModel) ： Vue 实例对象</li></ul><p>代码中：<br><img src="https://img-blog.csdnimg.cn/23db67de76cb45218247deede085d7d9.png#pic_center" alt="在这里插入图片描述"><br>在MVVM的架构下，View层和Model层并没有直接联系，而是通过ViewModel层进行交互。ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。因此开发者只需关注业务逻辑，无需手动操作DOM，复杂的数据状态维护交给MVVM统一来管理。</p><p>在Vue中对数据（Model）进行劫持，当数据变动时，数据会出发劫持时绑定的方法，对视图进行更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue核心--Vue简介、脚手架</title>
      <link href="/2022/05/30/Vue%E6%A0%B8%E5%BF%83--Vue%E7%AE%80%E4%BB%8B%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/05/30/Vue%E6%A0%B8%E5%BF%83--Vue%E7%AE%80%E4%BB%8B%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Vue就是一套用于构建用户界面的渐进式框架。具体介绍可以看下Vue官方的介绍 - <a href="https://cn.vuejs.org/v2/guide/">Vue.js</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>采用组件化模式，提高代码复用率、且让代码更好维护</p></li><li><p>声明式编码，让编码人员无需直接操作DOM，提高开发效率</p></li><li><p>使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点</p><h2 id="创建Vue-脚手架"><a href="#创建Vue-脚手架" class="headerlink" title="创建Vue(脚手架)"></a>创建Vue(脚手架)</h2><h4 id="脚手架创建"><a href="#脚手架创建" class="headerlink" title="脚手架创建"></a>脚手架创建</h4><pre><code class="javascript">vue create xxx </code></pre><p><img src="https://img-blog.csdnimg.cn/fa17380bc12241b58bdc815a70e242b8.png#pic_center" alt="在这里插入图片描述"><br>创建后在项目目录下通过<code>yarn serve</code>或<code>npm run serve</code>运行</p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src="https://img-blog.csdnimg.cn/03737265ea554cd3b2c0cc2a4932ba14.png#pic_center" alt="在这里插入图片描述"></p></li><li><p><code>favicon.ico</code>: 页签图标</p></li><li><p><code>index.htm</code>l: 主页面</p></li><li><p><code>assets</code>: 存放静态资源</p></li><li><p><code>component</code>: 存放组件</p></li><li><p><code>App.vue</code>: 汇总所有组件</p></li><li><p><code>main.js</code>: 入口文件</p></li><li><p><code>.gitignore</code>: git版本管制忽略的配置</p></li><li><p><code>babel.config.js</code>: babel的配置文件</p></li><li><p><code>jsconfig.json</code>: 指定了JavaScript 语言服务提供的功能的根文件和选项</p></li><li><p><code>package.json</code>: 应用包配置文件 </p></li><li><p><code>README.md</code>: 应用描述文件</p></li><li><p><code>yarn.lock</code>: 和package-lock.json文件相同作用：包版本控制文件</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpeechSynthesisUtterance语音播报的使用text-reader（HTML+CSS+Js）</title>
      <link href="/2022/04/24/SpeechSynthesisUtterance%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5%E7%9A%84%E4%BD%BF%E7%94%A8text-reader%EF%BC%88HTML+CSS+Js%EF%BC%89/"/>
      <url>/2022/04/24/SpeechSynthesisUtterance%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5%E7%9A%84%E4%BD%BF%E7%94%A8text-reader%EF%BC%88HTML+CSS+Js%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SpeechSynthesisUtterance"><a href="#SpeechSynthesisUtterance" class="headerlink" title="SpeechSynthesisUtterance"></a>SpeechSynthesisUtterance</h1><p>Web Speech API的SpeechSynthesisUtterance接口代表一个语音请求。它包含语音服务应阅读的内容以及有关如何阅读的信息（例如语言、音高和音量）。–引自MDN</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>SpeechSynthesisUtterance.lang </code><br>获取和设置说话的语言。<br><code>SpeechSynthesisUtterance.pitch</code><br>获取和设置说话的音调。<br><code>SpeechSynthesisUtterance.rate</code><br>获取和设置说话的速度。<br><code>SpeechSynthesisUtterance.text</code><br>获取并设置说话时将合成的文本。<br><code>SpeechSynthesisUtterance.voice</code><br>获取和设置将用于说语的声音。<br><code>SpeechSynthesisUtterance.volume</code><br>获取和设置说话的音量。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><code>boundary</code><br>当口语达到单词或句子边界时触发。<br><code>end</code><br>当口语结束时触发<br><code>error</code><br>当错误发生时触发，该错误导致无法成功说出该语句。<br><code>mark</code><br>当口语达到指定的SSML“mark”标记时触发。<br><code>pause</code><br>在说话暂停时触发<br><code>resume</code><br>当暂停的说话恢复时触发。<br><code>start</code><br>当开始说话时触发</p><p>小项目还是在github上面找的然后模仿着做的<br><img src="https://img-blog.csdnimg.cn/c331231462f948d1b1502a1aede2f115.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/f6c28552273c4c7bbde31b7162014cfc.png#pic_center" alt="在这里插入图片描述"><br>html代码</p><pre><code class="css">&lt;body&gt;    &lt;div class="container"&gt;        &lt;h1&gt;Speech Text Reader&lt;/h1&gt;        &lt;button class="btn" id="toggle"&gt;Toggle Text Box&lt;/button&gt;        &lt;div class="text-box show"&gt;            &lt;h3&gt;Choose Voice&lt;/h3&gt;            &lt;div id="close" class="close"&gt;X&lt;/div&gt;            &lt;select name="" id="voices"&gt;&lt;/select&gt;            &lt;textarea name="" id="text" placeholder="Enter text to read..."&gt;&lt;/textarea&gt;            &lt;button class="btn" id="read"&gt;Read Text&lt;/button&gt;        &lt;/div&gt;        &lt;main&gt;&lt;/main&gt;    &lt;/div&gt;    &lt;script src="script.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>css代码</p><pre><code class="css">* {    margin: 0;    padding: 0;    box-sizing: border-box;}body {    background-color: #ffefea;    min-height: 100vh;}.container {    text-align: center;    padding: 20px;}h1 {    margin: 20px 0;}.btn {    background-color: darksalmon;    color: white;    border-radius: 5px;    font-size: 16px;    padding: 8px;    border: 0 none;    cursor: pointer;}.btn:active {    transform: scale(0.98);}#toggle {    margin-bottom: 20px;}.text-box {    position: absolute;    top: 30%;    left: 50%;    width: 70%;    transform: translateX(-50%);    background-color: #333;    padding: 20px;    border-radius: 5px;    color: white;    transition: all 1s ease-in-out;}.close {    float: right;    cursor: pointer;}h3 {    float: left;    margin: 18px 0;}#voices {    background-color: darksalmon;    height: 30px;    width: 100%;    color: white;    cursor: pointer;    outline: none;}#text {    margin: 15px 0;    padding: 8px;    font-size: 16px;    border-radius: 5px;    width: 100%;    height: 150px;    resize: none;}#read {    width: 100%;}.show {    transform: translate(-50%, -200%);}main {    display: grid;    grid-template-columns: repeat(4, 1fr);    grid-gap: 10px;}.box {    display: flex;    flex-direction: column;    cursor: pointer;    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.718);    border-radius: 5px;    overflow: hidden;}.box.active {    box-shadow: 0 0 10px 5px darksalmon;}.box img {    width: 100%;    height: 200px;    object-fit: cover;}.box .info {    background-color: darksalmon;    padding: 10px;    color: white;    font-size: 18px;}@media (max-width:1100px) {    main {        grid-template-columns: repeat(3, 1fr);    }}@media(max-width:760px) {    main {        grid-template-columns: repeat(2, 1fr);    }}@media(max-width:500px) {    main {        grid-template-columns: 1fr;    }}</code></pre><p>js代码</p><pre><code class="javascript">var toggleBtn = document.querySelector('#toggle')var textbox = document.querySelector('.text-box')var closeBtn = document.querySelector('#close')var main = document.querySelector('main')var readBtn = document.querySelector('#read')var textarea = document.querySelector('#text')var voicesSelect = document.querySelector('#voices')toggleBtn.addEventListener('click', () =&gt;    textbox.classList.toggle('show'))closeBtn.addEventListener('click', () =&gt; {    textbox.classList.toggle('show')    textarea.value = ''})var data = [{        image: './img/drink.jpg',        text: "多喝热水"    },    {        image: './img/food.jpg',        text: "不要减肥"    },    {        image: './img/tired.jpg',        text: "多睡觉"    },    {        image: './img/hurt.jpg',        text: "啊哦"    },    {        image: './img/happy.jpg',        text: "病毒快死！"    },    {        image: './img/angry.jpg',        text: "疫情快滚！"    },    {        image: './img/sad.jpg',        text: "烦死人啦！"    },    {        image: './img/scared.jpg',        text: "好想出去玩"    },    {        image: './img/outside.jpg',        text: '世界多好'    },    {        image: './img/home.jpg',        text: '快出去！'    },    {        image: './img/school.jpg',        text: '想回学校！'    },    {        image: './img/grandma.jpg',        text: '呜呜呜'    }];data.forEach(createBox)function createBox(item) {    var box = document.createElement('div')    box.classList.add('box')    var { image, text } = item    box.innerHTML = `&lt;img src="${image}" alt="text"/&gt;&lt;p class="info"&gt;${text}&lt;/p&gt;`    box.addEventListener('click', () =&gt; {        setTextMessage(text)        speakText()        box.classList.add('active')        setTimeout(() =&gt; {            box.classList.remove('active')        }, 800);    })    main.appendChild(box);}var message = new SpeechSynthesisUtterance()var voices = []function setTextMessage(text) {    message.text = text}function speakText() {    speechSynthesis.speak(message)}speechSynthesis.addEventListener('voiceschanged', getVoices)readBtn.addEventListener('click', () =&gt; {    setTextMessage(textarea.value)    speakText()})function getVoices() {    voices = speechSynthesis.getVoices()    voices.forEach(voice =&gt; {        var options = document.createElement('option')        options.value = voice.name        options.innerHTML = `${voice.name}${voice.lang}`        voicesSelect.appendChild(options)    })}voicesSelect.addEventListener('change', function(e) {    message.voice = voices.find(voices =&gt; voices.name === e.target.value)})</code></pre><p>写的可能有点乱，都是想到哪写到哪，不会了就去看看人家咋写的了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML、CSS、JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的常用方法和命令</title>
      <link href="/2022/04/21/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/21/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><pre><code class="bash">1.#忽略所有.a文件*.a2.#跟踪index.html（即使前面用*.html忽略了所有html文件）!index.html3.#忽略当前目录下的index.css文件/index.css4.#忽略任何目录下名为index.html的文件夹index.html/5.#忽略 lib/1.txt(但不忽略 lib/dir/1.txt)lib/*.txt6.#忽略 doc/目录及其所有子目录下的.docx文件doc/**/*.docx</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看分支</p><pre><code class="bash">git branch</code></pre><p>基于当前分支创建 一个新分支</p><pre><code class="bash">git branch 分支名</code></pre><p>切换到某一分支上</p><pre><code class="bash">git checkout 分支名</code></pre><p>创建，并切换到新的分支上</p><pre><code class="bash">git checkout -b</code></pre><p>将分支合并到master</p><pre><code class="bash">git merge 分支名</code></pre><p>删除分支</p><pre><code class="bash">git branch -d 分支名</code></pre><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>查看远程仓库中所有分值列表信息</p><pre><code class="bash">git remote show</code></pre><p>从远程仓库把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</p><pre><code class="bash">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</code></pre><p>从远程仓库拉取当前分支最新的代码</p><pre><code class="bash">git pull</code></pre><p>删除远程仓库中指定名称的分支</p><pre><code class="bash">git push 远程仓库名 --delete 远程分支名</code></pre><p>移除仓库中的文件 但保留工作区的该文件</p><pre><code class="bash">git rm --cached 文件名</code></pre><p>同时移除工作区和仓库内的文件</p><pre><code class="bash">git rm -f 文件名</code></pre><p>从远程仓库克隆到本地</p><pre><code class="bash">git clone "url"</code></pre><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>撤销修改</p><pre><code class="bash">git checkout --文件名</code></pre><p>从暂存区内移除</p><pre><code class="bash">git reset HEAD 要移除的文件名或者全部（.</code></pre><p>查看最近两次提交记录</p><pre><code class="bash">git log -2</code></pre><p>在一行上显示提交历史</p><pre><code class="bash">git log --pretty=oneline</code></pre><p>回退到某一ID的版本</p><pre><code class="bash">git reset --hard &lt;CommitID&gt;</code></pre><p>在旧版本中使用<code>git log --pretty=oneline</code>命令 查看命令操作的历史</p><pre><code class="bash">git reflog --pretty=oneline</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用方法和命令</title>
      <link href="/2022/04/20/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/20/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="绑定用户名-邮箱"><a href="#绑定用户名-邮箱" class="headerlink" title="绑定用户名/邮箱"></a>绑定用户名/邮箱</h2><p>下载安装Git后通过Git Bash Here打开Git的命令行窗口配置用户信息。</p><pre><code class="bash">git config --global user.name "your username"git config --global user.email "your email"</code></pre><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>在现有目录中初始化仓库</p><pre><code class="bash">git init</code></pre><h2 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h2><p><code>add .</code> 是将所有文件添加到暂存区，当然也可以单独添加某一文件，将<code>.</code> 直接换为该文件名即可。</p><pre><code class="bash">git add .</code></pre><h2 id="将暂存区内容添加到仓库"><a href="#将暂存区内容添加到仓库" class="headerlink" title="将暂存区内容添加到仓库"></a>将暂存区内容添加到仓库</h2><p>也可以通过添加<code>-a</code> 参数，不需要执行<code>git add</code> 命令直接提交</p><pre><code class="bash">git commit -m "对于此次提交的描述"</code></pre><h2 id="建立远程仓库"><a href="#建立远程仓库" class="headerlink" title="建立远程仓库"></a>建立远程仓库</h2><p>在github或者码云创建新仓库后会有一个仓库的连接方式，可以通过HTTPS协议的连接方式，将自己的url替换到下面</p><pre><code class="bash">git remote add origin url</code></pre><h2 id="推送到代码托管平台"><a href="#推送到代码托管平台" class="headerlink" title="推送到代码托管平台"></a>推送到代码托管平台</h2><p>第一次推送需要加上<code>-u</code> 的参数，以后推送只需要<code>git push</code>命令格式为：<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></p><pre><code class="bash">git push -u origin main</code></pre><p>到此如果没什么问题的话在代码托管平台Github或者Gittee等就应该能看到自己仓库内有了本地的代码了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子模型</title>
      <link href="/2021/11/28/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8F%8AMargin,Border,Padding%EF%BC%89/"/>
      <url>/2021/11/28/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8F%8AMargin,Border,Padding%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>​    盒子模型(Box Modle)，所有的HTML元素都可以看做是一个盒子。CSS盒模型本质上就是一个盒子，然后用这个盒子来封装HTML标签。</p><h4 id="盒子的属性"><a href="#盒子的属性" class="headerlink" title="盒子的属性"></a>盒子的属性</h4><p>盒子总共有五个属性：</p><ul><li><p><code>width,height</code>(元素的高度、宽度)</p></li><li><p><code>Margin</code>(外边距)</p></li><li><p><code>Border</code>(边框)</p></li><li><p><code>Padding</code>(填充)</p></li></ul><p>盒子宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</p><p>盒子高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</p><h4 id="盒子中的区域"><a href="#盒子中的区域" class="headerlink" title="盒子中的区域"></a>盒子中的区域</h4><p><img src="https://i.loli.net/2021/11/28/mN4OogUyX7bqkrx.png" alt="IMG_20211128_144416.png"></p><h2 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h2><h4 id="Margin-1"><a href="#Margin-1" class="headerlink" title="Margin"></a>Margin</h4><p>Margin属性定义了元素周围的空间。可以单独改变元素的上、下、左、右边距，也可以一起改变。<code>Margin</code>没有背景颜色。</p><ul><li><p><code>Margin-top</code></p></li><li><p><code>Margin-right</code></p></li><li><p><code>Margin-bottom</code></p></li><li><p><code>Margin-left</code></p></li></ul><p>值：</p><ul><li><p><code>auto</code> - 设置浏览器边距，取决于浏览器</p></li><li><p><code>length</code> - 以px,pt,cm等单位制定</p></li><li><p><code>%</code> - 定义一个百分比的外边距</p></li></ul><h4 id="Margin的简写属性"><a href="#Margin的简写属性" class="headerlink" title="Margin的简写属性"></a>Margin的简写属性</h4><pre><code class="css">margin：50px 50px 75px 80px;</code></pre><ul><li><p>上外边距：50px</p></li><li><p>右外边距：50px</p></li><li><p>下外边距：75px</p></li><li><p>左外边距：80px</p></li></ul><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><h4 id="Border-1"><a href="#Border-1" class="headerlink" title="Border"></a>Border</h4><p><code>Border</code>(边框),边框有三个要素：粗细、线型、颜色。</p><h4 id="Border属性"><a href="#Border属性" class="headerlink" title="Border属性"></a>Border属性</h4><h5 id="Border-style"><a href="#Border-style" class="headerlink" title="Border-style"></a>Border-style</h5><p>边框的线型：</p><p>![@8HSU_4Y1RAJG_NN`2_HRVV.png](<a href="https://i.loli.net/2021/11/28/sjJYm5oLdMGpCO2.png">https://i.loli.net/2021/11/28/sjJYm5oLdMGpCO2.png</a>)</p><h5 id="Border-width"><a href="#Border-width" class="headerlink" title="Border-width"></a>Border-width</h5><p>属性制定四个边框的宽度。宽度设置依然是以px,pt,cm,em等长度进行计算。不过增加了以下三个预定值：<code>thin</code>,<code>medium</code>,<code>thick</code>。</p><p>同样边框的宽度也可以四条分别设定。</p><h5 id="Border-color"><a href="#Border-color" class="headerlink" title="Border-color"></a>Border-color</h5><p>属性设置四个边框的颜色。和<code>background</code>一样可以使用：<code>name(制定颜色名)</code>,<code>HEX(#fffff)</code>,<code>RGB(255,0,0)</code>等方式进行设定。</p><p>每一条边框的颜色也是可以单独进行设置的。</p><h4 id="Border的简写属性"><a href="#Border的简写属性" class="headerlink" title="Border的简写属性"></a>Border的简写属性</h4><pre><code class="css">border: 5px solid black;</code></pre><p><img src="https://i.loli.net/2021/11/28/gMaqsyNEoXUCiW5.png" alt="_H_5UBE47XTRO7497_GW_5K.png"></p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><h4 id="Padding-1"><a href="#Padding-1" class="headerlink" title="Padding"></a>Padding</h4><p><code>Padding</code>定义了元素边框与元素内容之间的空间。</p><p>填充也可以选择单一方向进行填充。</p><ul><li><p><code>padding-top</code></p></li><li><p><code>padding-right</code></p></li><li><p><code>padding-bottom</code></p></li><li><p><code>padding-left</code></p></li></ul><p>值：</p><ul><li><p><code>length</code> - 定义一个固定的填充以px,pt,cm等单位制定。</p></li><li><p><code>%</code> - 定义一个百分比的填充</p></li></ul><h4 id="Padding的简写属性"><a href="#Padding的简写属性" class="headerlink" title="Padding的简写属性"></a>Padding的简写属性</h4><pre><code class="css">padding:25px 30px 50px 100px;</code></pre><ul><li><p>上填充：25px</p></li><li><p>右填充：30px</p></li><li><p>下填充：50px</p></li><li><p>左填充：100px</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>background</title>
      <link href="/2021/11/22/css-background/"/>
      <url>/2021/11/22/css-background/</url>
      
        <content type="html"><![CDATA[<h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a><code>background-color</code></h3><p>css,颜色通常有以下方式表示：</p><ul><li><p>颜色名称</p></li><li><p>RGB</p></li><li><p>十六进制</p></li><li><p>RGBA</p></li></ul><pre><code class="css">background-color:red;background-color:rgb(255,0,0);background-color:#ff0000;background-color:rgba(255,0,0,0.6);</code></pre><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a><code>background-image</code></h3><p>css中可以通过<code>background-image</code>属性添加背景图片，不同的背景图片用逗号隔开。</p><pre><code class="css">background-image:url(background_img.jpg);</code></pre><h5 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h5><ul><li><p>线性渐变</p></li><li><p>径向渐变</p></li></ul><p>线性渐变</p><pre><code class="css">/*从上到下，绿色渐变到红色*/background-image:linear-gradient(green,red);/*以45度轴为渐变轴，从绿色渐变到红色*/background-image:linear-gradient(45deg,green,red);/*从左下到右上，从绿色渐变到红色*/background-image:linear-gradient(to right top,green,red);</code></pre><p>实例：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a64ed2547ef779afc6d778dbd9c54812.png" alt="image.png"></p><p>径向渐变</p><pre><code class="css">background-image:radial-gradient(shape size at position,start-color,···,last-color);</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ea5e8600c4c0ee8c00232510d72c094a.png" alt="a.png"></p><pre><code class="css">/*颜色节点不均匀分布*/background-image:radial-gradient(red 5%,green 15%,blue 60%);/*圆形径向渐变*/background-image:radial-gradient(circle,red,yellow,green);/*更多*/background-image: radial-gradient(closest-side at 60% 55%, blue, green, yellow, black);background-image: radial-gradient(farthest-side at 60% 55%, blue, green, yellow, black);}</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/d8965272641607f16b4d23b6a799c289.png" alt="q.png"></p><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a><code>background-repeat</code></h3><p><code>background-repeat:no-repeat;</code>设置背景图片的平铺属性，默认为平铺满。</p><ul><li><p>repeat</p></li><li><p>no-repeat</p></li><li><p>repeat-x</p></li><li><p>repeat-y</p></li></ul><p>(1)<code>repeat</code></p><pre><code class="css">background-image:repeat:repeat;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/1d79a8cbda8c2d4fd6601b48c8c949e6.png" alt="_83MFW_B__1Q6AIRGQW7FP5.png"></p><p>(2)<code>no-repeat</code></p><pre><code class="css">background-image:repeat:no-repeat;</code></pre><p><img src="https://i.loli.net/2021/11/16/IywbjX8196m5VJH.png" alt="9_`OX~XMZ8_YG`7E_QS_7~V.png"></p><p>(3)<code>repeat-x</code></p><pre><code class="css">background-image:repeat:repeat-x;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/65d10dee6b9db6f86f0114d08e935263.png" alt="GH~YPYDN}~EZPB@AF4H_PDV.png"></p><p>(4)<code>repeat-y</code></p><pre><code class="css">background-image:repeat:repeat-y;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/04d526170454d84c4151639ca8d264b0.png" alt="9eOyYpB15WESNJs.png"></p><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a><code>background-attachment</code></h3><p><code>background-attachment:scroll;</code>设置指定背景图像是否固定。</p><ul><li><p><code>fixed</code>(背景固定，不会滚动)</p></li><li><p><code>scroll</code>(背景会随页面其余部分一起滚动)</p></li></ul><p>(1)fixed</p><pre><code class="css">background-attachment:fixed;</code></pre><p><img src="https://i.loli.net/2021/11/28/9Nj4yieU2CXQnIc.png" alt="2c03e6da31e29182b435dca07e572686.png"></p><p>(2)scroll</p><pre><code>background-attachment:scroll;</code></pre><p><img src="https://i.loli.net/2021/11/28/8qUtifzo4uJrQHx.png" alt="d3171e6e27525c3a94345e7d79f987f5.png"></p><h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a><code>background-position</code></h3><p><code>background-position</code> 属性设置背景图像定位。</p><p><strong>提示：</strong>您需要把 <code>background-attachment</code> 属性设置为 “fixed”，才能保证该属性在 Firefox 和 Opera 中正常工作.</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ba8ab0a046080f2e303fd876099eb0b.png" alt="BW~DK5304XCOH(AGO(L{S36.png"></p><pre><code>background-position:200px,600px;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/7bf4d737c1061261609fbe7bd26f473b.png" alt="Q_9VNWPC_@21_WRSA_QDN8V.png"></p><pre><code class="css">background-position:center;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/fe09d9b154eed37cbfb2a80487faaf73.png" alt="QE_6FSXKYR~TB803QA_Z6MM.png"></p><h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a><code>background-origin</code></h3><p><code>background-origin</code> 属性指定<code>background-position</code>属性应该是相对于什么位置来定位。</p><ul><li><p><code>padding-box</code></p><p>背景相对于padding进行定位。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f41ef8a74dc0a98a9a68804b3dc9b48.png" alt="5S_3A~V_S9_Z6TKWXDU0BI8.png"></p></li><li><p><code>border-box</code></p><p>背景相对于边框进行定位。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/737272e269342acf63bb0b6e2931eb54.png" alt="image.png"></p></li><li><p><code>content-box</code></p><p>背景相对于内容盒子进行定位。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c37cb17dc6c654add9e7db776fc095ad.png" alt="image.png"></p><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a><code>background-clip</code></h3><p><code>background-clip</code> 规定背景的绘制区域。(与background-origin 不同的是 background-clip)</p><ul><li><code>border-box</code></li></ul><p>从边框开始显示超出<code>border-box</code> 的部分将裁剪掉。</p><ul><li><code>padding-box</code></li></ul><p>从内边距开始显示超出<code>padding-box</code> 的部分将裁剪掉。</p><ul><li><code>content-box</code></li></ul><p>从内容区域开始显示超出<code>content-box</code> 的部分将裁剪掉。</p><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a><code>background-size</code></h3><p><code>background-size</code>规定背景图片的尺寸大小。(本实例图片大小为465*465给定盒子大小为 500 * 600)。</p><ul><li><code>length</code></li></ul><p>设置背景图片高度和宽度。第一个值设置宽度，第二个值设置高度。如果只给出一个值，第二个则自动设置为auto。</p><pre><code class="css">background-size: 250px 250px;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/b92bd84859dc53a810572017468bf8a8.png" alt="image.png"></p><ul><li><code>percentage</code></li></ul><p>将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置高度。如果只给出一个值，第二个则自动设置为auto。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f8cfcdf4a856c09c33310d1188d921c.png" alt="image.png"></p><ul><li><code>cover</code></li></ul><p>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c62eb461ebe2a3ca5aedb510479fb64f.png" alt="image.png"></p><ul><li><code>contain</code></li></ul><p>保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca7fb93182278bf9f8db5ea71a82fa01.png" alt="image.png"></p><ul><li><code>cover</code></li></ul><p>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c62eb461ebe2a3ca5aedb510479fb64f.png" alt="image.png"></p><ul><li><code>contain</code></li></ul><p>保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca7fb93182278bf9f8db5ea71a82fa01.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（有符号数）</title>
      <link href="/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%EF%BC%89%EF%BC%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%89/"/>
      <url>/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%EF%BC%89%EF%BC%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h2 id="计算机组成原理（有符号数）"><a href="#计算机组成原理（有符号数）" class="headerlink" title="计算机组成原理（有符号数）"></a>计算机组成原理（有符号数）</h2><p><font color="#999AAA">原码、反码、补码以及移码问题，总是忘。其实都是很简单的规律。<img src="https://img-blog.csdnimg.cn/4966bfd9cf724d1da785c72017c471cc.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FfY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/80db298ed06645ca8e7e2a23b7195922.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ2FfY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></font></p><font color="#999AAA"></font>]]></content>
      
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2021/08/04/Makefile/"/>
      <url>/2021/08/04/Makefile/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">Makefile是一个文本文件，是GUN make 程序执行时默认读取配置的文件。</font></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="一、Makefile的工作原理"><a href="#一、Makefile的工作原理" class="headerlink" title="一、Makefile的工作原理"></a>一、Makefile的工作原理</h1><pre><code class="powershell">{目标文件}：{依赖文件1}{依赖文件2}···    {命令1}    {命令2}       ·       ·       ·</code></pre><p>通过一个或多个依赖文件执行成一个目标文件。并且依赖文件之间可以相互嵌套。</p><h1 id="二、使用Makefile"><a href="#二、使用Makefile" class="headerlink" title="二、使用Makefile"></a>二、使用Makefile</h1><h2 id="1-编写5个-c文件和4个-h文件"><a href="#1-编写5个-c文件和4个-h文件" class="headerlink" title="1.编写5个.c文件和4个.h文件"></a>1.编写5个.c文件和4个.h文件</h2><p>1.c</p><pre><code class="c">include&lt;stdio.h&gt;#include"1.h"int test_1(){        printf("test_1.......\n");        return 0;}</code></pre><p>1.h</p><pre><code class="c">int test_1();</code></pre><p>2.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"2.h"int test_2(){        printf("test_2.......\n");        return 0;}</code></pre><p>2.h</p><pre><code class="c">int test_2();</code></pre><p>3.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"3.h"int test_3(){        printf("test_3.....\n");        return 0;}</code></pre><p>3.h</p><pre><code class="c">int test_3();</code></pre><p>4.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"4.h"int test_4(){        printf("test_4.....\n");        return 0;}</code></pre><p>4.h</p><pre><code class="c">int test_4();</code></pre><p>5.c</p><pre><code class="c">#include&lt;stdio.h&gt;#include"1.h"#include"2.h"#include"3.h"#include"4.h"int main(){        test_1();        test_2();        test_3();        test_4();        return 0;}</code></pre><h2 id="2-创建编写Makefile文件"><a href="#2-创建编写Makefile文件" class="headerlink" title="2.创建编写Makefile文件"></a>2.创建编写Makefile文件</h2><pre><code class="c">Main:1.o 2.o 3.o 4.o 5.o        gcc 5.c 4.c 3.c 2.c 1.c -o Main1.o:1.c 1.h        gcc -c 1.c2.o:2.c 2.h        gcc -c 2.c3.o:3.c 3.h        gcc -c 3.c4.o:4.o 4.h        gcc -c 4.c5.o:5.c 1.h 2.h 3.h 4.h        gcc -c 5.cclean:        rm Main 1.o 2.o 3.o 4.o 5.o</code></pre><p>Main为目标文件，*.o文件是他的依赖文件。通过gcc5个.c文件生成可执行文件Main</p><p>1.o是目标文件，1.c和1.h是他的依赖文件。通过gcc 1.c生成1.o文件。下同。<br>最后是Makefile的clean规则，在当前目录下输入make clean再次查看目录会发现可执行文件Main和*.o文件没有了。</p><h2 id="3-make"><a href="#3-make" class="headerlink" title="3.make"></a>3.make</h2><p>在目录下输入make后生成可执行文件Main，执行该文件。</p><p><img src="https://img-blog.csdnimg.cn/20210416205035570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">Makefile可以完美解决每次编译程序的时候都要输入完整的命令和编译文件名以及参数的问题。省去了繁杂的编译命令，节省了时间。</font></p><font color="#999AAA"></font>]]></content>
      
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--v-指令</title>
      <link href="/2021/08/04/Vue%E4%B9%8Bv-%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/08/04/Vue%E4%B9%8Bv-%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="v-指令"><a href="#v-指令" class="headerlink" title="v-指令"></a>v-指令</h1><h2 id="1-v-text"><a href="#1-v-text" class="headerlink" title="1.v-text"></a>1.v-text</h2><p><font color="#999AAA">v-text指令的作用是设置内容的标签，设置文本。数据定义在data中。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-text="message"&gt;&lt;/h2&gt;        &lt;h2 v-text="message2"&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "learn",                message2: "hello"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="2-v-html"><a href="#2-v-html" class="headerlink" title="2.v-html"></a>2.v-html</h2><p><font color="#999AAA">v-html指令的作用是设置innerHTML标签。与v-text不同于v-text只解析为文本。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;p v-html="content"&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                content: "&lt;a href='https://www.csdn.net/'&gt;CSDN&lt;/a&gt;"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="3-v-on"><a href="#3-v-on" class="headerlink" title="3.v-on"></a>3.v-on</h2><p><font color="#999AAA">事件绑定用于监听DOM事件，绑定的方法定义在methods中。v-on还可以简写为@。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;input type="button" value="v-on指令" v-on:click="one"&gt;        &lt;input type="button" value="v-on简写" @dblclick="two"&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            methods: {                one: function() {                    alert("单击了一下");                },                two: function() {                    alert("双击666");                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="4-v-if-v-show"><a href="#4-v-if-v-show" class="headerlink" title="4.v-if/v-show"></a>4.v-if/v-show</h2><p><font color="#999AAA">在指令条件表达式返回值为true是进行渲染</font></p><font color="#999AAA"><p>v-show<br><font color="#999AAA">通过控制样式的display属性，渲染的元素始终保留在DOM中。如果运行的条件很少改变可以选择使用v-show指令。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-show="isShow"&gt;show hello&lt;/h2&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isShow: true            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>v-if<br><font color="#999AAA">会根据条件来决定条件块内监听器和组件的销毁和重建。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;h2 v-if="temp === 'a'"&gt;看见了1&lt;/h2&gt;        &lt;h2 v-else-if="temp === 'b'"&gt;看见了2&lt;/h2&gt;        &lt;h2 v-else="temp === 'c'"&gt;看见了3&lt;/h2&gt;        &lt;input type="button" value="next" @click="change1" @dblclick="change2"&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                temp: "a"            },            methods: {                change1: function() {                    this.temp = 'b';                },                change2: function() {                    this.temp = 'c';                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="5-v-bind"><a href="#5-v-bind" class="headerlink" title="5.v-bind"></a>5.v-bind</h2><p><font color="#999AAA">元素绑定，操作元素属性的指令。</font></p><font color="#999AAA"><p>v-bind:class<br><font color="#999AAA">根据条件执行class列表内容，来动态的操作class。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div v-bind:class="{active:isActive}" style="width:200px;height: 200px;text-align: center;line-height: 200px;"&gt;v-bind&lt;/div&gt;        &lt;!-- &lt;div class="static" v-bind:class="active:isActive,'text-danger" :hasError&gt;&lt;/div&gt;        &lt;div class="static active"&gt;&lt;/div&gt; --&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isActive: true,                // hasError: false            },        })    &lt;/script&gt;    &lt;style&gt;        .active {            background-color: #ff0000;        }    &lt;/style&gt;&lt;/body&gt;</code></pre><p>v-bind:style<br><font color="#999AAA">操作元素的内联样式</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div v-bind:style="isStyle"&gt;v-bind&lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                isStyle: {                    height: '100px',                    width: '100px',                    fontsize: '20px',                    color: 'red',                    background: 'black',                }            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="6-v-for"><a href="#6-v-for" class="headerlink" title="6.v-for"></a>6.v-for</h2><p><font color="#999AAA">响应式的根据数据生成列表结构</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        &lt;div&gt;v-for            &lt;ul&gt;                &lt;li v-for="item in arr"&gt;                    {{ item }}                &lt;/li&gt;            &lt;/ul&gt;            &lt;h2 v-for="(item,index) in str"&gt;                {{ acc }} - {{ index }} - {{ item }}            &lt;/h2&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                arr: ["a", "b", "c", "d"],                str: ["one", "two", "tree"],                acc: "time"            },        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="7-v-model"><a href="#7-v-model" class="headerlink" title="7.v-model"></a>7.v-model</h2><p><font color="#999AAA">表单元素双向绑定，绑定的数据与表单元素值相关联。</font></p><font color="#999AAA"><pre><code class="html">&lt;body&gt;    &lt;div id="app"&gt;        v-model        &lt;input type="text" v-model="message"&gt;        &lt;h2&gt; {{ message }} &lt;/h2&gt;    &lt;/div&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "123"            }        })    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。–就是好用就完了。</font></p><font color="#999AAA"></font></font></font></font></font></font></font></font></font></font></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--创建第一个项目</title>
      <link href="/2021/08/04/vue--%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/04/vue--%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="#999AAA">vue作为前端三大框架之一，对于前端开发非常重要。</font></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="一、vue是什么？"><a href="#一、vue是什么？" class="headerlink" title="一、vue是什么？"></a>一、vue是什么？</h1><p><font color="#999AAA">Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</font></p><font color="#999AAA"><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-创建一个vue项目"><a href="#1-创建一个vue项目" class="headerlink" title="1.创建一个vue项目"></a>1.创建一个vue项目</h2><p><font color="#999AAA">可以通过vue CLI<br>vue create 进行创建</font></p><font color="#999AAA"><pre><code class="powershell">vue create hello-word</code></pre><p>也可以通过图形化界面创建</p><pre><code class="powershell">vue ui</code></pre><p>会进入一个浏览器窗口，可以再窗口中进行项目的创建、配置等。<br><img src="https://img-blog.csdnimg.cn/20210416150312629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-项目的运行"><a href="#2-项目的运行" class="headerlink" title="2.项目的运行"></a>2.项目的运行</h2><p><font color="#999AAA">在终端中输入命令</font></p><font color="#999AAA"><p>如果是使用yarn使用</p><pre><code class="powershell">yarn serve</code></pre><p>使用npm就是</p><pre><code class="powershell">npm serve</code></pre><p>项目运行起来就可以在终端打开<br><img src="https://img-blog.csdnimg.cn/20210416150936956.png" alt="在这里插入图片描述"><br>点开URL就看到<br><img src="https://img-blog.csdnimg.cn/20210416151141332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTUyNDczNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color="#999AAA">从头开始，这就是第一个vue项目。</font></p><font color="#999AAA"></font></font></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue--&#39;el&#39;</title>
      <link href="/2021/07/11/Vue--%E2%80%98el%E2%80%98%E6%8C%82%E8%BD%BD/"/>
      <url>/2021/07/11/Vue--%E2%80%98el%E2%80%98%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1.png" alt="avatar"></p><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;">将DOM组件渲染塞入页面的过程<font color="#999AAA"></font><hr style=" border:solid; width:100px; height:1px;" color="#000000" size="1&quot;"><font color="#999AAA"><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;el:挂载点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        {{ message }}    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = new Vue({            el: "#app",            data: {                message: "挂载！"            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><font color="#999AAA">el命中挂载的元素内部可以通过Vue管理。</font></p><font color="#999AAA"><h2 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h2><p>通常使用id选择器因为通常id选择器是唯一的，而类选择器等都可用于多个元素容易造成语意不清而混乱。</p><h2 id="2-挂载标签"><a href="#2-挂载标签" class="headerlink" title="2.挂载标签"></a>2.挂载标签</h2><p>可以挂载到除和以外大多数双标签上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>挂载也是使用Vue的重要的一步。</p></font></font>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
