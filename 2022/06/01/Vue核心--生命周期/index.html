<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Vue核心--生命周期</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/head.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="﻿&amp;gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。

所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 created: () =&amp;gt; this.fetchTodos())。因为箭头函数绑定了父级上下文，所以 this 不会指向预期的组件实例，并且this.fetchTodos 将会是 undefined。

最开始我们应该是要通过new创建一个Vue的实例化对象。生命周期钩子：.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Aucanon's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Vue核心--生命周期</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81"><span class="toc-text">销毁</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Vue"><i class="tag post-item-tag">Vue</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Vue核心--生命周期</h1><time class="has-text-grey" datetime="2022-05-31T16:00:00.000Z">2022-06-01</time><article class="mt-2 post-content"><p>﻿&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<blockquote>
<p>所有生命周期钩子的 this 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着你不应该使用箭头函数来定义一个生命周期方法 (例如 <code>created: () =&gt; this.fetchTodos()</code>)。因为箭头函数绑定了父级上下文，所以 <code>this</code> 不会指向预期的组件实例，并且<code>this.fetchTodos</code> 将会是 undefined。</p>
</blockquote>
<p>最开始我们应该是要通过new创建一个Vue的实例化对象。<br><img src="https://img-blog.csdnimg.cn/25b04662b91747ad8231c5a2181f62b9.png#pic_center" alt="在这里插入图片描述"><br>生命周期钩子：<br>分为四个阶段四对钩子<br>|阶段| 钩子 |  |<br>|–|–|–|<br>| 初始化 | beforeCreate| created|<br>| 挂载 |beforeMount| mounted |<br>| 更新 | beforeUpdate | updated |<br>| 销毁 | beforeDestroy | destroyed |</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p><code>beforeCreate</code>：在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。<br> ——在此时没有Vue实例，访问不到data中的数据和methods内的方法。</p>
</blockquote>
<p>执行完后开始进行数据的初始化，这个过程会定义data数据、方法及事件，并完成数据劫持observe以及给组件实例配置watcher观察者实例。</p>
<blockquote>
<p><code>created</code>：在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。<br>——完成了实例的创建，已经能够访问到data中的数据和methods中的方法了。</p>
</blockquote>
<p>确保有了<code>el</code>之后会判断有没有<code>rander</code>函数，如果没有就回去找<code>template</code>将其转换为<code>rander</code>函数。</p>
<blockquote>
<p><code>beforeMount</code>:在挂载开始之前被调用：相关的 render 函数首次被调用。<br>该钩子在服务器端渲染期间不被调用。<br>——此时DOM结构未经过Vue编译，没有将编译的HTML渲染到页面。</p>
</blockquote>
<p>渲染<code>rander</code>函数，产生一个虚拟DOM并进行新老DOM之间的对比计算后进行保存，然后直接将rander渲染为真实DOM。</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><blockquote>
<p><code>mounted</code>:实例被挂载后调用，这时 el 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<br>该钩子在服务器端渲染期间不被调用。<br>——可在此进行：开启定时器、订阅消息、发送网络请求、绑定自定义事件等。</p>
</blockquote>
<p>在<code>mounted</code>函数内可以进行DOM操作，因为在此DOM已经渲染完成了。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><blockquote>
<p><code>beforeUpdate</code>:在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。<br>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。<br>——此时数据是新的，但页面是旧的。</p>
</blockquote>
<p><code>beforeUpdate</code>调用之后会生成新的虚拟DOM然后再拿回去和旧的进行diff算法的对比计算。更新<code>rander</code>函数并将新的<code>rander</code>函数渲染成真实DOM。</p>
<blockquote>
<p><code>updated</code>:在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br>注意，<code>updated</code> 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 <code>updated</code> 里使用 <code>vm.$nextTick</code><br>——此时数据和页面都是新的。</p>
</blockquote>
<p>在update中也可以操作DOM而且是已经更新后的DOM。</p>
<blockquote>
<p><code>before</code>:实例销毁之前调用。在这一步，实例仍然完全可用。<br>该钩子在服务器端渲染期间不被调用。<br>——可在此进行关闭定时器、取消订阅消息、解绑自定义事件等。</p>
</blockquote>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>beforeDestroy之后会进行一系列的销毁动作。解除各种数据引用、移除事件监听、删除组件watcher、删除子实例、删除自身self等。并将实例属性<code>_isDestroyed</code>设置为true。</p>
<blockquote>
<p><code>destroyed</code>：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。<br>该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/06/01/Vue%E6%A0%B8%E5%BF%83--filter%E8%BF%87%E6%BB%A4%E5%99%A8/" title="Vue核心--filter过滤器"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Vue核心--filter过滤器</span></a><a class="button is-default" href="/2022/06/01/Vue%E6%A0%B8%E5%BF%83--%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E7%9B%91%E4%BA%8B%E5%B1%9E%E6%80%A7/" title="Vue核心--计算属性、监事属性"><span class="has-text-weight-semibold">Next: Vue核心--计算属性、监事属性</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Aucanon/Aucanon.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Aucanon"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><a title="rss" target="_blank" rel="noopener nofollow" href="/atom.xml"><i class="iconfont icon-rss"></i></a><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Aucanon 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/Aucanon/" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>